344 - Operating System Notes

Block 1
======================================================================================

Intro to OS1 video 1
--------------------------------------------------------------------------------------


*nix - very stable

Operating System - software program that sits between software apps and the computational hardware


Program: stored algo or plan of execution

Process: program that has been loaded into memory and is executing

Thread: a line of execution in a process


Standard OS Services

1) Process and thread mgmt
	-> strt new pgm
	-> end proc/thread
	-> debug

2) File i/o mgmt
	-> bits into meaningful structures: files
	-> interfaces for r/w to files
	-> comm w/ external devices
	-> organizing files: directories


3) Interprocess Communication (IPC)
	-> signals, pipes, network sockets (TCP/IP)
	-> including between 2 diff comps


4) Process coordination (contention mgmt)
	-> contention mgmt leads to shared access


Interaction with OS:

Users: GUI and CMD line shell

PGMs:
	Functions: sys calls and API - fns

	Network comms:  msg-based and conn-based




Intro to UNIX  video 2
--------------------------------------------------------------------------------------

Jan 1 1970 - "time zero" for UNIX
	-> text processing added so other people/departments could use UNIX

UNIX rewritten in C in 1972
	-> unix couldn't be turned into a product due to regulations

Linux - initially developed by Linus Torvalds
	-> Unix like
	-> all the little kernel like things that tell it how to do everything can't be shared due to license agreements
	-> this is copied (form of it) and called Linux
	-> adopts POSIX UNIX specs
		-> aka code written here shouldn't need many changes to run on Linux
	-> very stable, robust, and free
	-> first version released 1994


Many distros: kernel + tools
	-> Ubunutu, openSUSE, Red Hat, Debian, Arch Liniux, Chrome OS, Mint etc.
	-> all downloadable, some can be purchased


Distros created with different purposes and features in mind
	-> Ubuntu installs evertyhing easily
	-> Arch Linux is opposite, requiring everything to be installed manually
	-> Tails is built to be private from the ground up


What is the shell? (Modern systems have a GUI, but we are going to look at the shell)

	-> this is the user interface to the operating system - a text-based command line interpreter aka prompt

	-> Provides acces to all UNIX user-lvl pgms
		-> start pgms
		-> manage processes (job ctrl)
		-> connect together processes (pipes)
		-> manage i/o to and from processes (redirection)
		-> kill pgms


Shell Prompts:
	-> traditional prompt and cursor - your commands go after the prompt
	-> customizable

	-> $ - typical prompt for BASH



ls -a (-a is the switch to show hidden files)


Most Common UNIX Commands:

directory/file mgmt:
	-> cd, pwd, ls, mkdir, rmdir, mv, cp, rm, ln, chmod

	cd: navigate directories
		~ to home

	pwd: print out current path

	ls: show files/folders in current directory
		-pla
			p: slash
			l: long format
			a: show both visible and hidden folders

		alias: alias l="ls -pla --color=auto"
			-> can type l and this will perform the above command. Kind of like a variable

			*** can be placed into ~/.bashrc so it will be run each time you log into this comp ***

	mkdir: create directory
		-> mkdir tempdir

	rmdir: delete directory
		-> rmdir tempdir  (may not work if not empty)

	rm: delete files (and directories if used recursively)
		NOTE: OSU auto subs rm -i so it has a y/n option to ensure you don't accidentaly delete the file

		-> rm myfile

		-> rm -rf tempdir
			r: delete dir and all files in it
			f: "don't ask me, just do it"

	mv: move or rename files and directories
		-> mv myfile tempdir
			This recognizes if tempdir exists, it will move the file there

		-> my myfile_backup myfile

	cp: copy files and directories
		-> cp myfile myfile_backup

		-> cp myfile ../newfile
			Creates a copy of myfile named newfile 1 folder up

	touch myfile: creates a file if it doesn't exist (0 bytes)
		-> if it does exist, it will update the last used timestamp



file viewing and selecting:
	-> cat, more/less, head, tail, grep, cut

editors:
	-> vi, (x)emacs, pico, textedit

other useful commands:
	-> script, find, telnet, ssh, and many more!


shell auto opens the terminal for reading-from, with one file and for writing-to with 2 files:

when running program ls (or another program):
	
	it comes into existance and has 3 files ready to go

		1) Standard In (file descriptor 0)
			stdin

		2) Standard Out (1)
			stdout

		3) Standard Error (2)
			stderr

			
If you don't specify otherwise, pgm input/output goes to and from the shell prompt by default on every line


Common UNIX Commands - Getting Data from Files:

	echo - sends character data to standard out

		echo test text: outputs test text
			-> sends data to stdout (not screen)
				-> since stdout is to the terminal, it displays to the terminal

		-e - interpret special characters
			echo -e "test text\nnext line"
						test text
						next line

	cat - concatenate character data stored in a file with char data from other files
		-> primarily to dump data to the terminal
		-> sends data to stdout unless explicityly changed from the terminal


	redirecting stdout:  >  operator   (a file is about to be the redirect)

		echo -e "cookie\nbeefcake\napple" > foodlist
		ls  (shows foodlist)
		cat foodlist

			cookie
			beefcake
			apple


	sort - takes data from stdin OR a file and sends the data, alphabetically sorted by line, to stdout

		sort foodlist

			apple
			beefcake
			cookie

	redirecting stdin: <  operator (tells stdin to open from a diff file for reading)

		sort < foodlist
				-> bash opens up the name file, sends the data as input to the pgm on left
				-> sort, meanwhile, has no 1st argument, so it reads data from stdin, and does not know where the data comes from!  It gets sorted and sent to stdout.

			apple
			beefcake
			cookie

	stdin with no redirection: (will be used in program 1)

		cat > list
			-> cat doesn't have an arg and attempts to read from stdin
			-> stdin still has terminal open for input
				-> so, we can get input from the keyboard line by line
					-> hit return after each line
				-> to stop, ^d
			-> bash takes the data from the pgm on left, opens the name file and writes the data into it

		cat list .. will print this data


	sort command can be given input and an output location on same line
		sort < foodlist > sortedList

		or

		sort >sortedList <foodlist
			-> spaces not necessary
			-> not read left to right

		-nr
			n: numeric sort
			r: reverse order

	Shell Filename Expansion
		-> certain metacharacters are expanded and replaced with all files with matching names

		* - matches anything
		? - matches any one characters

		(not regular expression encoding - grep)

	Pipes
		-> provides a way to communicate between commands without using temporary files to hold the data

		echo -e "cookie\nbeefcake\napple" | sort

		echo -e "cookie\nbeefcake\napple" > foodlist
		cat foodlist | sort

		cat foodlist | sort > sortedList
		cat sortedList
				-> cat foodlist piping into sort command then sends it to sortedList

		*a pipe takes the stdout of one command and connects it to the stdin of the next*



	>> operator appends

	more - takes char data and display sonly one screen-full at a time;
		-> nav up, down  and spacebar; quit with q



 

Shell Scripting (bash) video 3
--------------------------------------------------------------------------------------

all commands accessible from shell can be placed into a shell "script"
	-> executed line by line, as if being typed in line by line

shell script
	-> high level
		-> vars, conditionals, loops, etc
	-> interpreted
		-> no compiling, no var dec, no mem mgmt (like js)
	-> powerful/efficient
		-> do a lot with a little code
		-> can interface with any UNIX pgm that uses stdin, stdout, stderr
	-> string and file oriented

	-> used to automate tasks
	-> simplify complex commands, etc
	-> often used to glue pgms together


	Hello World!
	--------------

	#!/bin/bash                        // #! shebag chars (# normally comment) 1st line tells UNIX the path to 											the shell with which to interpret the script
	# Obligatory programming example   // comment
	echo Hello World! 					// line to execute begins here


	Variables:

	assigning (very weakly typed)
		myint=1
		myint=Ben

	to display:
		echo $myint 

	Quotation marks - protecting the text
		-> control expansion of variables within strings of text

		single quotes: no variable expansion

			$  printf 'all your base $abtu\n'
				all your base $abtu
					-> ignored variable


		double quotes: variables are expanded
			$  printf "all your base $abtu\n"
				all your base are belong to us


		\ means to eval literally instead of interpret
		nt="NOTTACHANCE"
		printf "\$nt"; printf "$nt\n"
			result: $ntNOTTACHANCE


Printing example - built from scratch

echo "#!/bin/bash"
	-bash: !/bin/bash": event not found
		-> because the history feature engages when ! is the first character

echo "#\x21/bin/bash"
	-> without -e argument, the hex ASCII code 21 for ! won't be expanded

finally:

echo -e "#\x21/bin/bash" > cAd
echo -e "echo \"cat\"\necho \"doge\"\necho \"kat\"\necho \"doug\"" | sort >> cAd
chmod +x cAd    - make this file be executable, more on chmod later
cAd


We coudl write in emacs, vi, pico, etc...
If ^M (different line endings)
	-> Windows CR and LF
		-> CR returns back to left
		-> LF moves everything up
	-> unix machine = single character

	dox2unix will convert windows line endings to those used by UNIX


Shell keywords:
	-> cmds in bash that are interepred by shell as delimiters, branching constructs, and loops,e tc..

	compgen - generates possible completion matches for various categories of keywords
		-k  all reserved keywords

	AKA, NO KEYWORDS AS VARIABLES

			if
			then
			else
			elif
			fi
			case
			esac
			for
			select
			while
			until
			do
			done
			in
			function
			time
			{
			}
			!
			[[
			]]
			coproc


Environment variables
	-> set of vars that are always available in your shell
	-> ctrl options that change the operation of the shell

	few common ones:
		PATH - set of directories bash will search through to find a command
		HOME - shortcut bak to the home directory (equivalent to ~)
		SHELL - full path ot the default shell
		HOSTNAME - name of the computer you're currently using

		printenv to see all + current contents

		Ex:
		echo $PATH
			-> the directories from left to right (sequentially) will be searched for the command I would have entered


Special Parameters
	-> set of vars always avail in script

	common ones:
		$ - the process ID of the script itself (every running process has a unique PID)
		? - the return value of the previously terminated command or script
		# - the number of args (positional parms) given when a script is executed
		1 - the first arg (pos parms) as of when the script was ran
		2 - the 2nd arg (pos parm) as of when the script was ran
		3, 4, etc.. more on Build-In Shell Variables page

Return Values Examined

exit (bash) and exit() (C) fn rtn results to ? var

cat exittest

		bash if:
		if cmd list
		then
			cmd list
		elif
			cmd list
		then
			cmd list
		else
			cmd list
		fi

Error handling
	-> shell will keep exe'ing even if cmds have the wrong syntax, del files, break things, and general havoc

	-> want shell to exit if any cmds have a prob (rtn non-0 val)
		-> use -e with /bin/bash

		#!/bin/bash -e

	could also do:

	#!/bin/bash
	if cp thesis.docx thesis_current.docx
	then
		rm -f thesis.docx
	else
		echo "copy failed" 1>&2
		exit 1
	fi



	-> most signals will kill script immediately
		-> EG CTRL-C sends SIGINT

For loop:

		$ cat forloop
		#!/bin/bash
		for i in a b c d
		do
		printf "<%s>" $i
		done
		printf "\n"

		$ forloop
		<a><b><c><d>
		$


While loop:

	$ cat whileloop
	#!/bin/bash
	i=0
	while test $i -ne 2
	do
		printf "i = $i, not stopping yet\n"
		i=$(expr $i + 1)
	done
	printf "Stopping, i = $i\n"

	$ whileloop
	i = 0, not stopping yet
	i = 1, not stopping yet
	Stopping, i = 2


Subshells
	-> some operators (like =) and cmds req strings or #s to operate on, not other cmds:

	$ cat sumtest
	#!/bin/bash
	num1=9
	num2=3 + $num1  <- this shit don't work.. need subshells
	echo "num2: $num2"

	$ sumtest
	./sumtest: line 3: +: command not found
	num2:

	-> if we want to increment or set to an arbitrary value, we first have to calc that value and rtn it as TEXT to the script, then the script can continue

	-> these are executed as entirely separate shells (called subshells) in their own processes that run and rtn

	Original method to do this:
		i=`expr $i + 1`    ---- BACKTICKS!

	Preferred method: POSIX compiant, doesn't need escaping when nested
		i=$(expr $i + 1)

	-> both methods eval the exp and grab res's from stdout of the subshell
	-> dbl parens construct does arithmetic expansion and eval directly, no expr cmd needed
			i=$(( 9 + 9 ))
			(( i++ ))


Common UNIX Cmds - Trapping Signals
	-> we are touching really quick here then coming back in block 3

	-> trap - command to catch signals (like SIGINT generated by hitting CTRL + C) and clean up yer mess

	Usage:
		trap <code to execute> list of signals

	Example:

		#!/bin/bash
		TMP="myCoolFilename$$" <- $$ will give process id
		trap "rm -f $TMP; echo 'CTRL+C received, exiting'; exit 1" INT HUP TERM
		echo "lotsa text" > $TMP
		while [ 1 -ne 2 ]
		do
		echo "Never ending loop - hit CTRL+C to exit!"
		done



Bash Script Demos video 4
--------------------------------------------------------------------------------------

readloop

	$ cat readloop
	#!/bin/bash
	while read myLine
	do
		echo "$myLine"
	done < $1  <-------- stuffs contents of file, whos name is the str in the 1st arg, into the 					while loop
	$ readloop test_file
	1 1 1 1 1
	9 3 4 5 5
	6 7 8 9 7
	3 6 8 9 1
	3 4 2 1 4
	6 4 4 7 7
	$


arrayloop  (not recommended for program 1 as it can get complex)

	$ cat arrayloop
	#!/bin/bash
	array=( one two three )
	for i in "${array[@]}"
	do
		echo $i
	done

	$ arrayloop
	one
	two
	three

	$


forloop

	$ cat forloop
	#!/bin/bash
	oneline="1 2 3 4 5"
	for i in $oneline
	do
		echo "i is: $i"
	done

	$ forloop
	i is: 1
	i is: 2
	i is: 3
	i is: 4

sumloop

	$ cat sumloop
	#!/bin/bash
	sum=0
	TMP1=./tempfile
	echo -e "8\n7\n6" > $TMP1

	while read num
	do
		echo "In Loop"
		echo "num: $num"
		sum=`expr $sum + $num`
		echo "sum: $sum"
		echo -e "End of Loop\n"
	done < $TMP1


	$ sumloop
	In Loop
	num: 8
	sum: 8
	End of Loop

	In Loop
	num: 7
	sum: 15
	End of Loop
 
	In Loop
	num: 6
	sum: 21
	End of Loop


stdinread

	$ cat stdinread
	#!/bin/bash
	cat > "tempfile"  -- terminal waits here for input, contd when hit CTRL-D(EOF)
	cat tempfile

	$ stdinread
	I like cheese
	I like cheese


trtest
purpose: convert a row file into a column file and back again

#!/bin/bash
# This script converts a row file ./tempinputfile into a column file ./tempcolfile,
# then back into a row file ./temprowfile<PID>

inputFile="tempinputfile"
tempCol="tempcolfile"
tempRow="temprowfile"

# Make the input row file
echo -e "1\t2\t3\t4\t5" > $inputFile

# Append each number onto the end of a temporary column file by cutting specific columns
cut -c 1 $inputFile > $tempCol
cut -c 3 $inputFile >> $tempCol
cut -c 5 $inputFile >> $tempCol
cut -c 7 $inputFile >> $tempCol
cut -c 9 $inputFile >> $tempCol

# Convert the column file back into a row file
cat $tempCol | tr '\n' '\t' > "$tempRow$$"

# Add a newline char to the end of the row file, for easier printing
echo >> "$tempRow$$"



tr = tranformation of something to something
	ex:
		$tempCol | tr '\n' '\t'   pipes stuff in the file to tr and makes all \n into \t


Wolf Fence Algo
	-> fancy way of saying comment out parts of the code when you can't find the source of the problem (divide and conquer)
		-> bifurcate the code by commenting out half of it and running
		-> change the code to ignore all of the input but one piece and run

when program crashes
	-> creates a core dump file (except with shell scripts)
	to view: gdb myprogram -c coredumpfile


Trace statements!!! - what and where
	-> print out the val of vars as you go (what)
	-> print out where you currently are (where)


		What and where:
		About to Begin Loop: j = 0
		Now At Start of Loop: i = 0, j = 0
		Sum() function ran: i = 1, j = 1844835813859
		Executed file read: i = 1, j = ^^^^^^^ºØĆ@«
		Contents of file read: fj8283jJ*#Jf8j32@fj
		Now at End of Loop: i = MDKMDKMDK, j = 42941492
		Start missile laun^C ^C ^C ^C


Debugging Bash Shell scripts

	Enable print of cmd traces before executing each command:
		-> add -x to the end of the first line of the script
			#!/bin/bash -x

	OR

	Launch the script w/ a shell that has cmd traces enabled:
		bash -x sumloop











Ways to run script:
chmod 755 scriptname   (gives permission to run the script)
	-> tool to set defaults is unmask, but we really don't want to set all files you create as executables
bash scriptname
chmod +x scriptname    <- should use this one to create the executable, then type scriptname





Everything is a File  video 6
--------------------------------------------------------------------------------------

Files:
	-> inodes with hard links that point to them

Inodes: maintained by the file system istelf and contain:
			-> pointers to the actual file data
			-> all meta-information (size, perms, etc..)
			-> a "reference count": how many hard links point to the inode
			-> a unique "inode number"

		HardLink1.txt -> INODE

Hard Link:
	-> text entry in a file system directory that points to an inode

	-> connects a text filename to an inode on disk

Directory:
	-> essential text files that organize hard links hierarchically
	-> create and remove
	-> read contents (in C)
		-> opendir(), closedir(), readdir(), rewinddir()


vim . : will give you a file with the files in that directory


Directories can be read like a file: this program looks for the newest timestamped file with a certain prefix

#include <stdio.h>
#include <string.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

void main() {
	int newestDirTime = -1; 				// Modified timestamp of newest subdir examined
	char targetDirPrefix[32] = "brewsteb.rooms."; 						// Prefix we're looking for
	char newestDirName[256]; 							// Holds the name of the newest dir that contains prefix
	memset(newestDirName, '\0', sizeof(newestDirName));
	DIR* dirToCheck; 								// Holds the directory we're starting in
	struct dirent *fileInDir; 					// Holds the current subdir of the starting dir
	struct stat dirAttributes; 					// Holds information we've gained about subdir
	dirToCheck = opendir("."); 					// Open up the directory this program was run in
	if (dirToCheck > 0) { 						// Make sure the current directory could be opened
		while ((fileInDir = readdir(dirToCheck)) != NULL) { 				// Check each entry in dir
		if (strstr(fileInDir->d_name, targetDirPrefix) != NULL) { 			// If entry has prefix
			printf("Found the prefex: %s\n", fileInDir->d_name);
			stat(fileInDir->d_name, &dirAttributes); 						// Get attributes of the entry
			if ((int)dirAttributes.st_mtime > newestDirTime) { 				// If this time is bigger
				newestDirTime = (int)dirAttributes.st_mtime;
				memset(newestDirName, '\0', sizeof(newestDirName));
				strcpy(newestDirName, fileInDir->d_name);
				printf("Newer subdir: %s, new time: %d\n", fileInDir->d_name, newestDirTime);
				}
			}
		}
	}
	closedir(dirToCheck); // Close the directory we opened
	printf("Newest entry found is: %s\n", newestDirName);
}


Creating Links:
	-> when you create a file (using touch, a C function, etc..)
		-> an inode is allocated and a hard link is automatically created

	-> can create multiple hard links to the same inode
		-> file can appear in multiple directories at the same time
		-> same file under different names
			-> even in same dir

	-> to create a link: use ln or link cmds


Removing Files in C
	-> approxly unlinking everything
		-> inode is garbage collected when ref count == 0

		-> unlink (filename)
			-> can't unlink dirs

		-> remove (filename)
			-> can remove empty dirs
			-> if it is a dir, identical to rmdir()

Symbolic Link
	-> like Windows shortcut - not actually a file, it pts to a hard link

	-> if you del, rename, or move the hard link a symbolic link points to,
	the symbolic link becomes unusable

	NewServer$ ln -s /nfs/rack/u2/b/brewsteb ./myFilesLink
	NewServer$ cd myFilesLink

	SymLink.txt -> HardLink1.txt -> INODE <- HardLink2.txt





$ mkdir 1
$ mkdir 2
$ touch ./1/hardlink1
$ ln ./1/hardlink1 ./2/hardlink2
$ ln -s ./1/hardlink1 ./symlink
$ find -samefile ./1/hardlink1
./1/hardlink1  <- these share an inode
./2/hardlink2
$ ls -plaR
.:
drwxrwx---. 1 brewsteb upg57541 124 Aug 29 15:11 ./
drwxrwx---. 1 brewsteb upg57541 636 Aug 29 14:56 ../
drwxrwx---. 1 brewsteb upg57541 84 Aug 29 15:11 1/
drwxrwx---. 1 brewsteb upg57541 84 Aug 29 15:11 2/
lrwxrwxrwx. 1 brewsteb upg57541 13 Aug 29 15:11 symlink -> ./1/hardlink1
./1:
drwxrwx---. 1 brewsteb upg57541 84 Aug 29 15:11 ./
drwxrwx---. 1 brewsteb upg57541 124 Aug 29 15:11 ../
-rw-rw----. 2 brewsteb upg57541 0 Aug 29 15:11 hardlink1       ^  \/ ref count: 2
./2:
drwxrwx---. 1 brewsteb upg57541 84 Aug 29 15:11 ./
drwxrwx---. 1 brewsteb upg57541 124 Aug 29 15:11 ../
-rw-rw----. 2 brewsteb upg57541 0 Aug 29 15:11 hardlink2




% ls -pla
drwxr-xr-x 2 brewsteb upg22026 512 Jun 22 16:44 ./
drwxr-xr-x 8 brewsteb ftp 1024 Jun 22 15:46 ../
-rw-r--r-- 1 brewsteb upg22026 1027 Jun 22 15:47 cursesDemo.c
-rw-r--r-- 1 brewsteb upg22026 42558 Jun 22 15:55 Curses.pdf
-rw-r--r-- 1 brewsteb upg22026 4208 Jun 22 16:24 index.html
-rw-r--r-- 1 brewsteb upg22026 61554 Jun 22 15:46 IntroToUnixShell.html
-rw-r--r-- 1 brewsteb upg22026 38 Jun 22 15:46 OnE1FAQ.txt
-rw------- 1 brewsteb upg22026 467 Jun 22 15:46 OnE1_sol.txt
-rw-r--r-- 1 brewsteb upg22026 288 Jun 22 15:46 OnE1.txt
-rw-r--r-- 1 brewsteb upg22026 38 Jun 22 15:55 Prog1FAQ.txt
-rw-r--r-- 1 brewsteb upg22026 8098 Jun 22 15:46 Prog1.html
-rw-r--r-- 1 brewsteb upg22026 7114 Jun 22 15:46 Prog1.test
-rw-r--r-- 1 brewsteb upg22026 38 Jun 22 15:46 Prog2FAQ.txt
-rw-r--r-- 1 brewsteb upg22026 4517 Jun 22 16:14 Prog2.html

-rw-r--r--  perms
1      hard link count
brewsteb     owner
upg22026  group owner
4517     size (bytes)
Jun 22 16:14    last modified
Prog2.html  name


Possibilities include:
• Hard links
• Symbolic links
• Named pipes
• Device character special file
• Device block special file
• Named socket



Unix perms: 3 classes of users
	-> user (owner of file)
	-> group
	-> all others

	3 kinds of access perms
		-> read
		-> write
		-> execute


chmod : change perms on a file by using change mode cmd


-rw-r--r-- 1 brewsteb upg22026 4517 Jun 22 16:14 Prog2.html
drwx--x--x 1 brewsteb upg22026 512 Jun 22 17:48 tempDir/

d    file type
rwx    user
--x  group
--x  others
1 brewsteb upg22026 512 Jun 22 17:48 tempDir/

traditional way to set is octal

	r = 4
	w = 2
	x = 1

	I.e d | rwx  |  r-x  | r-x
			7		5		5


$ chmod 644 Prog2.html   <- standard rights for a publicaly viewable WEBPAGE
$ chmod 755 tempDir     <- standard rights for a publicaly viewable DIRECTORY


Setting perms the easy way:


---------- 1 brewsteb upg22026 4517 Jun 22 16:14 Prog2.html



$ chmod u+rwx Prog2.html
-rwx------ 1 brewsteb upg22026 4517 Jun 22 16:14 Prog2.html

$ chmod g+rx,o+rwx Prog2.html
-rwxr-xrwx 1 brewsteb upg22026 4517 Jun 22 16:14 Prog2.html

$ chmod o-w Prog2.html
-rwxr-xr-x 1 brewsteb upg22026 4517 Jun 22 16:14 Prog2.html



umask
	-> creation mask setting defines the default perms for new files
	-> can set with umask

ex: umask 022
	-> this is inverted.  It sets the owner to have full perms, while the others don't have write.. opposite of 755



$ umask
0007   <-  actually 4 digits, far left = SUID, SGID, and sticky bits (rarely used)
$ touch tempfile
$ ls -pla tempfile
-rw-rw----. 1 brewsteb upg57541 0 Mar 30 08:17 tempfile
$ rm tempfile
rm: remove regular empty file ‘tempfile’? y
$ umask 022
$ umask
0022
$ touch tempfile
$ ls -pla tempfile
-rw-r--r--. 1 brewsteb upg57541 0 Mar 30 08:18 tempfile


du : returns the total usage in kb of the spec'd dir

df : same, but for entire filesystem

stat : gets metadata about the file


touch : creates files and modify time stamps

*** THIS IS A BAD IDEA  ****
rm -rf /*   <---- deletes all files on computer



rm -rf ./*  <--- deletes everything in cur dir and beneath.



VIM Lecture 1.7
-----------------------------------------------------------

$ - move to end of line
0 - beginning of line

^d - screen down half a screen
^u - up half a screen


Get into replace mode:

r - replace the char that the cursor is over w/ the next one typed
R - enter replace mode until we manually leave it


/pattern will search for a string pattern in the file

n - move you to the next instance of that pattern
N - previous instance

:nohl - remove highlighting after search

global search and replace:
	:%s/wrongtext/righttext/g



Advanced command mode

:!UNIXCOMMAND
	-> run single unix cmd from inside vi

:r!UNIXCOMMAND
	-> run single unix cmd and insert the output into the file


:sh -- new shell

cut - use d instead of y

yy - copy current line (opposite of dd)


x - del current char
dw - del cur word

xp - transpose current and next char
A - go into append/insert mode at the end of the line


O (big oh) - open new line above the cur line in insert mode
o (little o) - below cur line

d$ - del rest of line from where the cursor is
s - del cur char and enter insert mode


5dd - del 5 lines starting at the cur cursor position
		-> DOH!



Regular Expressions  video 8
--------------------------------------------------------------------------------------


Used by many unix pgms
	-> grep, sed, vi, emacs, regexp, etc...


used extensively by many scripting langs:
	-> python, perl, tcl/tk


grep - search for an occurance of a string that matches a pattern
	-> acts like a filter

$ cat fileToSearch

FINDME first line
second FINDME line
third line FINDME
fourth line FINDM3
fifth line
sixth lFINDMEine

$ grep "FINDME" fileToSearch

FINDME first line
second FINDME line
third line FINDME
sixth lFINDMEine


$ ps -ef | grep brewsteb
root 29541 3760 0 11:26 ? 00:00:00 sshd: brewsteb [priv]
brewsteb 29543 29541 0 11:26 ? 00:00:00 sshd: brewsteb@pts/1
brewsteb 29544 29543 0 11:26 pts/1 00:00:00 -csh
brewsteb 30737 29544 0 11:44 pts/1 00:00:00 ps -ef
brewsteb 30738 29544 0 11:44 pts/1 00:00:00 grep brewsteb


Jon            Will match any string that contains Jon anywhere



* - matches 0 or more of the previous char
	-> not same as cmd line usage

	FINDME*         FINDME or FINDMEE or FINDMEEE…

^ (circumflex)
	-> when placed at beginning of a RE, indicates the RE must start at the beginning of the string
^abc          Any string that starts with abc


$ (dollar sign)
	-> when placed at end of RE, matches the end of the string

XYZ$         Any string that ends with XYZ


*** if you don't use ^ and $, it will match substrings ***


^Ben Brewster$      Any string that matches “Ben Brewster” exactly




.     Matches any single character
\     Causes the following special character to simply be itself
			Like the period character itself
[abc]   Matches any one character inside the brackets
[^abc]  Matches any character except any of the ones inside
	-> [^a-z]
			-> all but anything a through z




Find all lines in all files that match a string:

r - search recursively down into each subdir
n - rtn line # of maching lines
~ - look everywhere from my home dir and deeper

$ grep -rn "dogsdogs" ~  
/nfs/stak/faculty/b/brewsteb/tempdir/greptests/catsdogs:4:i like dogsdogs



Finding things - find  - EX 1
	-> find a file by name and many other features
	-> can also exe cmds against the files found

find all files named digs starting at my home dir (recursion into dirs is implied):

$ find ~ -name digs
/nfs/stak/faculty/b/brewsteb/tempdir/greptests/digs



$ find ~ -name digs 2>/dev/null
	-> will take any errors and put them into a "black hole"




Ex 2:

$ find ~ -name digs -exec rm -i '{}' \;
rm: remove regular empty file
'/nfs/stak/faculty/b/brewsteb/tempdir/greptests/digs'? y


find all files named digs starting in home dir   $ find ~ -name digs
	-> exe the rm -i cmd    -exec rm -i
		-> against all files found by find   '{}'
			-> end the rm command   \;


Ex 3: find all with a specific thing in the name

$ find ~ -regex ".*fork.*" | sort
/nfs/stak/faculty/b/brewsteb/tempdir/doublefork
/nfs/stak/faculty/b/brewsteb/tempdir/doublefork.c
/nfs/stak/faculty/b/brewsteb/tempdir/forkexec
/nfs/stak/faculty/b/brewsteb/tempdir/forkexec.c
/nfs/stak/faculty/b/brewsteb/tempdir/forkFPsharing
/nfs/stak/faculty/b/brewsteb/tempdir/forkFPsharing.c
/nfs/stak/faculty/b/brewsteb/tempdir/forktest
/nfs/stak/faculty/b/brewsteb/tempdir/forktest.c
/nfs/stak/faculty/b/brewsteb/tempdir/forkwaittest
/nfs/stak/faculty/b/brewsteb/tempdir/forkwaittest.c
/nfs/stak/faculty/b/brewsteb/tempdir/forkyouzombie
/nfs/stak/faculty/b/brewsteb/tempdir/forkyouzombie.c
/nfs/stak/faculty/b/brewsteb/tempdir/pipeNfork
/nfs/stak/faculty/b/brewsteb/tempdir/pipeNfork.c
/nfs/stak/faculty/b/brewsteb/tempdir/pipeNfork_directEdit.c
/nfs/stak/faculty/b/brewsteb/tempdir/pipeNforkFIFO
/nfs/stak/faculty/b/brewsteb/tempdir/pipeNforkFIFO.c




Finding things - locate
	-> finds files using a db
	-> faster
	-> will be outdated and not avail on every system

		-> find is better



		



Block 2
======================================================================================

A Brief Review of C  video 1
--------------------------------------------------------------------------------------

C = high level lang
	-> not low level like assembly

O.G. version of C (C89)
	-> 32 reserved keywords
	-> 50+ ops and syntax chars


#include <stdio.h>

int main()
{
	printf("Hellow world\n");
	return 0;
}


or

int main()
{
	char* oblig = "Hello World";
	float itsOver = 9000.0f;
	printf("%s\n", oblig);
	printf("IT\'S OVER %.2f!\n", itsOver);

	return 0;
}


#include <string.h>

char* boring = "boring"
	-> string literal, can't change
		-> pretty sure this is because we are pointing to a specific block of memory
			and we can't change because that would change the memory allocated (such as overwriting)
		-> so, we would just point to a different string


length = strlen(weirdString);


string compare:

if (strcmp(str1, str2) == 0)
	equal
else
	not



char a[1000], b[1000]

gets(a);   < funtion sig: char * gets(char *str)

gets(b);


strcat(a, b);  strcat() dumps the results into a and returns the same
	-> so a is updated
	-> could overwrite stuff as it doesn't check the space allocated for a


substrings aren't built in:

while (c < length)
{
	sub[c] = string[position + c - 1];
	c++;
}
sub[c] = '\0';   // null terminator


char mychar;
mychar = 'C';
char* mypointer;
mypointer = &mychar;
char* mypointer2 = mypointer;
mypointer2 = &mychar2;
*mypointer2 = *mypointer;



From Programs to Execution  video 2
--------------------------------------------------------------------------------------


OS provides software access to the hardware in an abstracted manner


Memory = array of bytes
	-> this is a bunch of stuff from 271.. think back on that.. simple stuff but should remember.


Virtual Memory: hardware creates the illusion of:
	-> un-shared, exclusive memory
	-> unlimited memory (up to the max address size)


Typical organizatoin of program in memory:
	-> code segment - pgm instructions

	-> data segment - ini'd global and static vars in read/write and read-only sections
						-----------------------------------------------------------------
						un-ini'd g and s vars

	-> stack - automatic vars, fn rtn ptrs

	-> heap - dynamically allocated memory



stack
---------
local auto vars and fn rtn pts and pgm enters and exits scoped blocks of code

memory managed efficiently by CPU

Var size is limited by OS settings

Vars cannot be resized



heap
--------------

vars allocated manually: malloc(), calloc()

mem is unmanaged, so fragmentation can occur
	-> heap access is slower than stack

var size is unlimited (other than virtual mem lims)

vars can be resized with realloc()



compile / link process

	1) c pre-processor expands macros and strips out comments
		#include, #define, #ifdef, //, /* */, etc..

	2) compiler parses your source, chks for errors, and gens assembly code

	3) compiler calls the assembler, which converts assembly code to machine binary code.

	4) if compiling an exe, the linker step tries to match function calls to function code (in diff files)


GCC - standard unix compiler


-g 			compile w/ debugging for gdb
-c 			compile only w/o linking
-S 			generates assembly code
-O3 		optimizes as much as possible
-o 			specifies the name of the output file
-Wall 		turns on all warnings
-llibrary	adds support for library (library) when linking (for example, -lpthread)


personal note: Just create a makefile to use


compiling an exe:

	1 source .c file:
		gcc -o dbtest dbtest.c

	multiple files: (simpler method)
		gcc -o dbtest dbtest.c dbcreate.c dbopen.c


	separate compile and link: (more efficient)
		-> compile them one at a time w/o linking, then linke them all together at the end

		1)	gcc -c dbtest.c
			gcc -c dbcreate.c
			gcc -c dbopen.c
			gcc -c dbread.c

		2) link all object (.o) files together and create an exe
			gcc -o dbtest dbtest.o dbcreate.o dbopen.o


Library Archives:

	collections of .o files gathered into a single large file, with indexes to make accessing them faster
		-> usually faster than having to read every .o file
		-> easier to link w/ if you aren't changing the library object files frequenetly


	to create a library
		-> first create all the object files
		-> then use the ar command:
			ar -r libdb.a dbcreate.o dbopen.o dbread.o

			To use:
					gcc -o dbest dbtest.o libdb.a





Concurrency   video 3
--------------------------------------------------------------------------------------

-> doing multiple things at the same time
	-> pgm decomp into order-indpendednt chunks

-> easy on unix
	-> multiple process can be running simultaneously
	-> mult copies of same pgm
	-> cpu time split and shared


Defs: system call vs library functions

system calls:
	-> a request for service that causes the normal operation of a process to be interrupted and control passes to the OS

	-> typically, the process is now blocked and won't do anything else until the system call returns

	-> read(), write(), etc..

C lib funs:
	-> faster, as they have no perms or blocking issues
	-> sqrt(), printf(), etc.


Illusions of simul exec:
	
	-> multiprogramming
		-> more than one process ready to exec
		-> sys calls trigger "context switches", to let next proc run
		-> proc not exe again until its system call returns


	-> timesharing
		-> cput time split b/w multiple processes
			-> gives illusion that many procs are running at once


multiprocessing:
	-> exe mult procs at actual same time
		- multi cores!



Provide Access Control:
	-> if 1 proc writing, no other prcs should access (read or write) the resource

	-> "locks" solve these problems
		-> only procs owning the lock may access r/w the resource
		-> many ways to do
		-> usually reqs support from the OS


Kernel:
	-> central part of OS
	-> manages hardware (and drivers)
	-> provides the scheduler
	-> not interacted w/ by users: system calls are requests to the kernel

Scheduler
	-> distributes prioritized and/or fair CPU time


Imagine we have a chat server that needs to do 3 things:
	1) watch for users connecting
	2) send chat output to all users
	3) receive chat input from individual users

	What do we do?

		Threads - allows a proc to do all of these things at the same time

			Advs:
					comm b/w threads is vastly simpler than ipc
						-> share code, heap, data, can access other stacks

					cpu switches b/w exe threads much faster than between procs

			disAdv:

					race conditions

					resource contention, including file access

					leaking of sensitive data cross threads


	Posix thread - unix:

	#include <pthread.h>
		-> compile with -lpthread option in gcc

Creating a thread:

int pthread_create(		pthread_t* thread,
						const pthread_attr_t* attr,
						void* (*start_routine) (void *),
						void* arg
				  );


thread: pts to the var in which the ID of the new thread is written into
	-> depending on OS implementation, somtimes this is an int, somtimes struct

attr: pts to a pthread_attr_t struct that contains option flags (NULL if none)

start_routine: pts to a fn (in current pgm) that will be the start pt of execution for the new thread that copies this one

arg: pts to the sole arg that is passed into start_routine (null if none); if multiple args are desired, pass a struct


Example:

int resultInt;
pthread_t myThreadID;

restultInt = pthread_create( &myThread,
			NULL,
			start_routine,
			NULL );


Destroy a thread:
	-> calling pthread_exit()
	-> rtns from start_routine()
	-> from another thread calling pthread_cancel()
	-> exit() from any thread



identifying the executing thread:

pthread_t myThreadID = pthread_self();   (not necessarily an int)

test for equality:

pthread_equal(myThreadID, unknownThreadID);



in for loop:
	result_code = pthread_join(threads[index], NULL);
		-> block until thread 'index' completes



If lectures don't do more, look up some info on threading:
pthread library, pthread_create, join
also review voided fns and fn ptrs


Mutexes  (mutual exclusion)
	-> implemented as part of the POSIX pthread api to privde thread synchronization via "locks"
	-> provides the prgmmr the ability to protect data from multiple read/writes on same files
	-> several types which check variously for errors, perform faster, etc..


Lifespan of a mutex:

pthread_mutex_t myMutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_destroy(myMutex);


Mutex locking:
	-> thread acquires a lock on a mutex var by attempting to call a special lock fn:

		pthread_mutex_t myMutex = PTHREAD_MUTEX_INITIALIZER;
		pthread_mutex_lock(myMutex);

			-> once mutex is locked, any other thread attempting to lock it will block


	unlocking:
		-> thread unlocks a mutex var that it has previously locked:
			pthread_mutex_unlock(myMutex);

		-> once locked, 1 of other block threads (chosen essentially randomly) currenlty blocked on the mutex will unblock and gain the lock

		-> non-blocking attempt to lock the mutex:
			int resultCode = pthread_mutex_trylock(myMutex);


Mutex Generalized:
	Mutex = form of a semaphore which come in 2 types:
		-> counting semaphore
			-> allow some soft of arbitrary resource count, e.g. # of avail buffers
		-> binary semaphore
			-> equal to 1 or 0, indicating locked/unavailable or unlocked/available
	-> invented by Edsger Dijkstra in the early 1960s



Brewster's delightful imagery on the topic:

A mutex is not the actual object in question. I think you get that, but let me extend the fridge analogy a bit. Imagine that the mutex is a squirrel. By convention, we're going to agree that only the person holding the squirrel is allowed to use the fridge.

 So, person A comes along, picks up the squirrel, then uses the fridge. While she is in the fridge, person B comes along. NOTHING is stopping person B from getting into the fridge while person A is using it, except we've agreed to use the convention of the squirrel holder. So, person B attempts to get the squirrel but is rebuffed by person A. Person B now is stuck: he's not doing anything else but asking for the squirrel. Constantly. Annoyingly.

As soon as person A puts down the squirrel (unlocks the mutex) - whether or not she is done with the fridge, so be careful to get the timing of these events correct - person B grabs it (locks the mutex), and then immediately starts accessing the fridge.
 
Now let's imagine that Persons C, D, and E arrive, and they all try to grab the squirrel from Person B (they all call lock on the mutex). Person B fights them off (it's already locked), but they all stay right next to him, doing nothing, just trying to grab the squirrel (they're blocked). Here's an important point: as soon as Person B puts down the squirrel, there's a free-for-all fight for it. It will be essentially random as to whom between Persons C, D, and E get the squirrel! Picture three people fighting over a docile woodland animal in a cramped kitchen with a well-stocked fridge and you'll have the perfect mental model of the use of a mutex.




File Access in C  video 4
--------------------------------------------------------------------------------------

What is a file in unix?
	-> stream of bytes


opening a file:

read only :: O_RDONLY
write only :: O_WRONLY
read and write :: :: O_RDWR


file pointer (default start pos = 0)


char file[] = "cs344/grades.txt";
int file_descriptor;
// fopen and fclose are for file streams rather than file descriptors

file_descriptor = open(file, O_RDONLY);

if (file_descriptor < 0)
	fprintf(stderr, "could not open %s\n", file);
	exit(1);

close (file_descriptor);
return 0;



truncating an existing file:

	file_descriptor = open(file, O_WRONLY | O_TRUNC);


O_APPEND = appending flag (set to end of file)


create a new file:
	file_descripter = open(filepath, O_WRONLY | O_CREAT, 0600);
		-> 0600 = permissions. don't pass in, C will fail in bizarre and silent ways

	octal number perms:
		-> specify directly as with chmod: 0600
		-> bit-wise OR flags together: S_IRUSR | S_IWUSR


lseek()
	-> manipulates file ptr in a file
	-> used to ctrl where you're messing with "da bitz"

	move to byte #16:
		newpos = lseek(file_d, 16, SEEK_SET);
			-> SEEK_END based on end pos
			-> SEEK_CUR from current pos

read():
	read(fd, &buffer, 10)	
	buffer: #!/bin/bas
	(file stream of bytes = "#!/bin/bash\n ")


Good practice to avoid nasty bugs:
	nwritten = write(file_d, giveEm, strlen(giveEm) * sizeof(char));
	
	mmemset(readBuffer, '\0',  sizeof(readBuffer)); // clear out array b4 using
	lseek(file_d, 0, SEEK_SET); //reset the file ptr to beginning of file
	nread = read(file_d, readBuffer, sizeof(readbuffer)); 



stdio.h:

fopen, fclose, printf, fprintf, scanf, fscanf, getc, putc, gets, fgets.. etc..
	-> auto buffers input/output
	-> easy to work in line mode r/w 1 line at a time
	-> powerful string and number formatting

	Why teach and use read() and write() ?
		-> max performance when you know exactly what you are doing


Files or Streams
	stdin, stdout, and stderr are file streams, not file system files
		-> f streams wrap around and provide buffering to the underlying file descriptor among other features
		-> stdio lib streams are connected with fopen() call to a var type FILE*
			FILE* myFile = fopen("datafile1", "r");
		-> streams closed when process terminates
		-> raw file d's w/ open files are passed on to child processes:
			-> process spawns a new child proc w/ fork(), all open files are shared b/w parent and child procs


stat() and fstat()
	-> get info about a file or dir



Strings in C  video 5
--------------------------------------------------------------------------------------
not a native type and ends in \0

printf()  -  prints to stdout
sprintf() -  prints to string (a char array)
fprintf() -  p to file
						-> all look for null terms


common lib fns:
	strcmp()
	strlen()
	strcpy()
	strcat()

	n-char versions:
		strncpy
		strncat


1) char* mystring 		= "mystring";
	-> at compile time creates a sequ of bytes in the READ ONLY INITIALIZED DATA SEGMENT portion of memory w/ the contents of "mystring"
	-> during exe, creates ptr on stack called mystring that pts to read only seq of chars
	-> can be ptded to by other addresses

2) char  mystring[]		= "my string";
	-> creates space for 10 bytes on the stack
	-> puts "my string" into the var mystring with null term after it
	-> editable as an array

3) char  mystring[20]	= "my string";
	-> creates space for 20 bytes on stack
	-> "my string" into mystring w/ null term
	-> editable as array


Watch out for buffer overruns when writing strings.


DONT:
char mystring[20];
strcpy(mystring, "my string");

Better, but not safe:
char mystring[20] = "my string";   // may not be portable

Preferred:
char mystring[20];
memset(mystring, '\0', 20);
strcpy(mystring, "my string");


Declaration:

char* mystring[3];			// array of pts each which pt to a string
		-> remember, array name is a ptr to first elements address

note: interesting way to find length:
	sizeof(mystring) / sizeof(mystring[0])


dyanmically allocating a string:
malloc() and free()

char* mystring;

mystring = mallow(20 * sizeof(char));

code...

free(mystring);






C Debugging  video 6
--------------------------------------------------------------------------------------

To reproduce:
	simplifiy input and env until replicated at will
		-> Wolf Fence algo (50% cuts)

Debugger with gcc

	compile with the "-g" optoin:
		gcc -g testit.c -o testit
		then start debugger on pgm:
			gdb ./testit

	impt cmds in debugger

		run :: (re)starts pgm running - will stop at brkpt
		break :: sets brkpt 
		step :: executes single line of code, will enter a fn call
		next :: exe single line of code, not enter fn call
		continue :: continues exe again untl brkpt or end pgm
		print :: pritns out a var
		quit :: stop debugging (exit gdb)


valgrind:
	gcc -o leaky -g leaky.c
	valgrind --leak-check=yes --show-reachable=yes ./leaky

	-> printf could cause valgrind to lie about reachable/unreachable allocated memory



Mixing Languages  video 7
--------------------------------------------------------------------------------------

Another always built in language for scripting: awk

awk:
	-> commonly used for writing one line pgms on unix systems

	Ex:
		#!/usr/bin/awk -f
		BEGIN {print "Hello, world!"; exit }

	associative arrays
		-> maps arbitrary objs to arbitrary objs
				-> as opposed to numbers to arb objs

		ex:
			myarray[0] = "dog"
			myarray["cat"] = "feline"
			myarray[3] = 6

			sparse array b/c there are breaks in the int numbering from 0 to 3

			associ arrays are also called: map, hash, lookup table


Perl: practical extraction and report language (general purpose lang)
	-> borrows from C, shell scripting, awk, sed, Lisp, and others
	-> easy, but not elegant
	-> interpreted

	ex:

		#!/usr/bin/perl
		# the traditional first pgm.

		# strict and warnings are recommended
		use strict;
		use warnings;

		# print msg
		print "Hello, World!\n";

Python: faster and OOP support
	-> interpreted

	ex:
		#!/usr/bin/python
		print "Hello World!";

		#!/usr/bin/python
		# Create a file for writing
		file = open("myfile.dat", "w+")
		file.write("STUFF N JUNK")


C is much faster than Python

to see time:
	/usr/bin/time --format='%C %e seconds' pgmNameHere


scripting langs and compiled langs can call each other
	-> allows us to combine the best parts of one with the other:
		speed == c
		short and easy to pgm == python

Mixing C into Python (doesn't return any results back to the python script)

	#!/usr/bin/python
	from subprocess import call
	call("./c-billion")

ways to get data back into python:
		(should be able to do 1st 2 after this course)
	-> have c pgm write a data file, read by python
	-> create a UNIX pipe, from which both python and C can read and write
	-> crate a C fn inside the Python pgm with the "instant" module
	-> several other complex ways such as Python C API, ctypes, SWIG, Boost python api, etc.. all which
		use additional wrappers or APIs to manipulate and translate data.

Can also mix python into C (strings!)

mixing C into bash Shell Scripting:

cat addsix-c.c
#include <stdio.h>
int main(int argc, char*argv[])
{
	printf("%d", atoi(argv[1]) + 6);
	return 0;
}

gcc -o addsix-c addsix-c.c

#!/bin/bash
value=4
printf "value: %d\n" $value
value=$(./addsix-c $value)
printf "value + addsix: %d \n" $value

chmod +x addsix-bash
addsix-bash

value: 4
value + addsix: 10




Block 3
======================================================================================

Processes   video 1
--------------------------------------------------------------------------------------

Process mgmt = necessary component of a multiprogrammable OS

Process: an instance of an executing pgm, w/ a collection of execution resources associated with it.

UNIX Process comps:
	-> unique identity (process id aka pid): pid_t pid = getpid();
	-> virtual address space (from 0 to mem lim)
	-> pgm code and data in mem
	-> user/grp identity
	-> exec environment all to itself
	-> resource lims, scheduling priority
	-> etc..

Program: exec code
process: running an instance of a pgm
	-> more than 1 proc concurrently exec same pgm code w/ sep proc resources


Process States:

Running (on cpu)
Waiting: for I/O, timer alarm, or signal - also known as blocked
Runable: waiting for cpu.

Zombie: exited, waiting for parent to clean it up


How do you create a proc?
	-> let the shell do it for you (when exec a pgm)
	-> in some cases, you'll want to do it yourself (shell assignment)
	-> unix provides a C API for creating and managing procs explicitly


	Fns in api we will cover:
		i)		fork()
		ii) 	exec() family:
					-> execl()
					-> execlp()
					-> execv()
					-> execvp()
		iii) 	exit()
		iv)		wait(), waitpid()
		v)		getpid()
		vi)		getenv(), putenv()



fork() : starts a new process
	-> clones proc A into B (nearly identical)
		-> diff pid's
		-> each returns a diff val from fork()
		-> P B gets cpies of all open file descriptors of Proc A
		-> has same vars set to same vals, but now separately managed

$ cat forktest.c

#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

void main()
{
	pid_t spawnpid = -5;
	int ten = 10;

	spawnpid = fork();
	switch (spawnpid)
	{
		case -1:   /* returns -1 if something went wrong - to the parent proc - sets global var errno */
			perror("Hull Breach!");
			exit(1);
			break;
		case 0: 	/* in child proc, fork rtns 0 */
			ten = ten + 1;
			printf("I am the child! ten = %d\n", ten);
			break;
		default:	/* in parent proc, fork rtns proc id of child proc created */
			ten = ten - 1;
			printf("I am the parent! ten = %d\n", ten);
			break;
	}
	printf("This will be executed by both of us!\n");
}

Key items inherited:
	-> pgm code
	-> creds
	-> vm contents (incld stack/heap)
	-> open file descriptors
	-> close on exec flags
	-> signal handling settings
	-> etc..


Key items UNIQUE to the child proc:
	-> proc id
	-> parent proc id is diff (it's the parent that just spawned it)
	-> own copy of file d's
	-> process, text, data, and other mem locks are NOT inherited
	-> pending signals init'd to the empty set

Child proc termination:
	-> exits for 2 reasons
		1) completes exec and exits normally
			case 1) child proc completed the needful (haha) and exited w/ sucessful exit status 			of 0
			case 2) child p encountered error cond, recognized it, and exited with non-S exit 				status (non 0)

		2) it was killed by a signal
			-> child p was sent a signal that by default terms a process and the child proc did not catch it

	How do parents check to see if child p's have terminated? 	(checking exit status)
			-> both fns, you pass a ptr to which the OS writes an int, which identifies how the child exited
				-> not a simple integer that can be easily read

		wait() : will block - until any one child proc termiantes; rtns the proc id of the term'd child
				pid_t wait(int *childExitMethod);


		waitpid() : same as wait, but with the specified proc ID being term'd
			-> can pass special flag to not block (no hang)
				pid_t waitpid(pid_t pid,
							  int *childExitMethod,
							  int options);

		Examples:

			block this parent until any child proc terms:
				childPID = wait(&childExitMethod);

			block this parent until the spec'd child proc terms:
				childPID_actual = waitpid(childPID_intent, &childExitMethod, 0);

			check if any process has completed, rtn immediately w/ 0 if none have:
				childPID = waitpid(-1, &childExitMethod, WNOHANG);

			chk if the proc spec'd has completed, rtn immediately w/ 0 if it hasn't:
				childPID_actual = waitpid(childPID_intent, &childExitMethod, WNOHANG);


		proper waitpid() placement:

		$ cat forkwaittest.c

		#include <sys/types.h>
		#include <unistd.h>
		#include <stdio.h>
		#include <stdlib.h>

		void main()
		{
			pid_t spawnPid = -5;
			int childExitMethod = -5;

			spawnPid = fork();
			if (spawnPid == -1) //
			{
				perror("Hull Breach!\n");
				exit(1);
			}else if (spawnPid == 0) // Terminate the child process immediately
			{
				printf("CHILD: PID: %d, exiting!\n", spawnPid);
				exit(0);
			}

			printf("PARENT: PID: %d, waiting...\n", spawnPid);
			waitpid(spawnPid, &childExitMethod, 0);  // blocks parent until child proc terms
													 // with spec'd PID terms
			printf("PARENT: Child process terminated, exiting!\n");
			exit(0);
		}

		$ forkwaittest
		PARENT: PID: 3311, waiting...
		CHILD: PID: 0, exiting!
		PARENT: Child process terminated, exiting!


	Checking Exit Status - Normal Termination:


		wait(&childExitMethod) and waitpid(.., &cEM, ..) can identify 2 ways a proc can term

		If the proc terms normally, then the WIFEXITED macro returns non-zero:
			if(WIFEXITED(childExitMethod) != 0)
				printf("The process exited normally\n");

		Can get the actual exit status with WEXITSTATUS macro:
			int exitStatus = WEXITSTATUS(childExitMethod);

	CES - Signal Termination

		term'd by a signal, then WIFSIGNALED macro rtns non-zero:
			if(WIFSIGNALED(childExitMethod) != 0)
				printf("The process was terminated by a signal\n");

		get terminating signal w/ WTERMSIG macro:
			int termSignal = WTERMSIG(childExitMethod);


	CES - Exclusivity
		-> barring the use of non-std WCONTINUED and WUNTRACED flags in waitpid(), only 1 of the WIFEXITED() and WIFSIGNALED() macros will be non-zero
			-> if you want to know how a child proc died, you need to use both
				-> WIFEXITED and WIFSIGNALED

		if child proc has term'd normally, do not run WTERMSIG() on it, as there is no signal # that killed it

		if child proc was term'd by a signal, do not run WEXITSTATUS() on it, as it doesn't have an exit status (i.e. no exit() or return () fns were exec'd)

		int childExitMethod;
		pid_t childPID = wait(&childExitMethod);
		
		if (childPID == -1)
		{
			perror("wait failed");
			exit(1);
		}
		if (WIFEXITED(childExitMethod))  // non-0 evals to True in C
			{
			printf("The process exited normally\n");
			int exitStatus = WEXITSTATUS(childExitMethod);
			printf("exit status was %d\n", exitStatus);
		}
		else
			printf("Child terminated by a signal\n");  // this statement is true, but
											// it never hurts to exame WIFSIGNALED() to be sure



	What if you want to start a process that is running a completely different program?
		-> exec()


	exec..() - Execute
		-> exec...() replaces the currently running pgm with a new pgm that you specify
		-> fns do NOT rtn - they destroy the currently running pgm
			-> no line after exec() call will run
		-> can spec args to exec..() : these become the cmd line args that show up as 
			-> argc/argv in C, and as the $1, $2, etc positional parms in a bash shell

		2 types!

			1)		int execl(char *path, char *arg1, .., char*argn);
				-> execs pgm spec'd by PATH, and gives it the cmd line args spec'd
					by strings arg1 through argn

			2) 		int execv(char *path, char *argv[]);
				-> execs pgm spec'd by PATH, and give cmd line args indicated
					by the ptrs in argv

			exexl and execv do not examine the PATH var - they only look in the current working directory (see next slide notes)

			-> if you don't spec fully qualified path name, then pgms will not be exec'd
				-> even if they are in a directory listed in PATH, and execl and execv will rtn with an error

			To move around the dir structure in C, use:

				getcwd() :: gets the current working dir
				chdir() :: sets the cwd

	Easier way: exec..() and the PATH variable

		int execl(char *path, char *arg1, .., char*argn);
		int execlp(char *path, char *arg1, .., char*argn);

		int execv(char *path, char *argv[]);
		int execvp(char *path, char *argv[]);

		Versions ending with p will search your PATH environment var for the executable given in a path
			-> in general, use the version with p as they are much more convenient


		-> exec..() replaces the pgm it is called from, does NOT create a new proc
			-> using fork and exec we can keep our original pgm going and spawn a new proces
				** this is how a shell works **
					-> note exec..() does NOT change the proc id, where fork does
						-> the fork is essentially killed off and the exec replaces it
							with the same process ID

		passing parms to execlp()
			int execlp(char *path, char *arg1, .., char*argn);

			1st parm: path name of new pgm
			remaining parms: "cmd line args"
				-> 1st arg should be the same as the 1st parm (the cmd itself)
				-> last arg must always be NULL, which indicates no more parms
				-> do NOT pass any shell-specific operators into any member of exec..() family
					ex: <, >, |, &, or !
						-> the shell is not being invoked - only the OS is!
			Ex:
				execlp("ls", "ls", "-a", NULL);

		Full example:

		#include <sys/types.h>
		#include <unistd.h>
		#include <stdio.h>
		#include <stdlib.h>

		void main() {
			pid_t spawnPid = -5;
			int childExitStatus = -5;
			
			spawnPid = fork();
			switch (spawnPid) {
				case -1: { perror("Hull Breach!\n"); exit(1); break; }
				case 0: {
					printf("CHILD(%d): Sleeping for 1 second\n", getpid());
					sleep(1);
					printf("CHILD(%d): Converting into \'ls -a\'\n", getpid());
					execlp("ls", "ls", "-a", NULL);
					perror("CHILD: exec failure!\n"); // only reason it would get here is if ls 										failed
					exit(2); break;
				}
				default: {
					printf("PARENT(%d): Sleeping for 2 seconds\n", getpid());
					sleep(2);
					printf("PARENT(%d): Wait()ing for child(%d) to terminate\n", getpid(), spawnPid);
					pid_t actualPid = waitpid(spawnPid, &childExitStatus, 0);
					printf("PARENT(%d): Child(%d) terminated, Exiting!\n", getpid(), actualPid);
					exit(0); break;
				}
			}
		}

$ gcc -o forkexec forkexec.c
$ forkexec
PARENT(8201): Sleeping for 2 seconds
CHILD(8204): Sleeping for 1 second
CHILD(8204): Converting into 'ls -a'
. cAd Ctests forkyouzombie leaky2 python-billion
.. catsAndDogs dollars forkyouzombie.c leaky2.c python-billion-fast
addsix-bash c-billion doubleparen forloop leaky3 pythonmath
addsix-c c-billion.c error.txt greptests leaky3.c pythonstring
addsix-c.c cstring-array exiter hardlink1 leaky.c pythontest
array-of-pointers cstring-array.c forkexec havoc malloctest readerror
array-of-pointers.c cstring-array-unint forkexec.c hw malloctest.c readpipetest
arraytest cstring-array-unint.c forktest hw.c memerrors readtest
arraytest.c cstring-inlinearray forktest.c inodetest paramtest rowfile
arraytest.c.backup cstring-inlinearray.c forkwaittest killthesis perlcamel rowfile2
billion cstring-segfault.c forkwaittest.c leak2.c_backup permissionstests sortdata
PARENT(8201): Wait()ing for child(8204) to terminate
PARENT(8201): Child(8204) terminated, Exiting!


	Passing parms to execvp()
				int execvp(char *path, char *argv[]);

					-> path name, then array of ptrs to strings
						-> last in array must be NULL

				Example:
					char* args[3] = {"ls", "-a", NULL};
					execvp(args[0], args);

$ cat execvptest.c

#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

void execute(char** argv)
{
	if (execvp(*argv, argv) < 0)
	{
	perror("Exec failure!");
	exit(1);
	}
}
void main()
{
	char* args[3] = {"ls", "-a", NULL};
	printf("Replacing process with: %s %s\n", args[0], args[1]);
	execute(args);
}

$ gcc -o execvptest execvptest.c

$ execvptest
Replacing process with: ls -a
. .. execvptest execvptest.c


exit() :

	atexit()
		-> arrange for fn to be called b4 exit()

	exit()
		-> calls fns registerd by atexit()
		-> flushes all stdio output streams
		-> removes files created by tmpfile()
		-> then calls _exit()


	_exit()
		-> closes all files
		-> cleans up everything (see man page for wait() for complete list)

	return() from main() does exactly the same thing as exit()



Environment variables
	-> set of txt vars often use to pass info b/w the shell and C pgm

	may be useful if:
		-> need to spec a config for apgm that you call frequently (LESS, MORE)
		-> need to spec a config that will affect many diff cmds that you execute
			(TERM, PAGER, PRINTER)

	view/edit the environ from bash by using the printenv and export cmds, and assignment (=) operator

	environ can be edited in C with setenv() and getenv()

Bash:

	MYVAR="Some text string 1234"
	export MYVAR
	echo $MYVAR
	MYVAR="New text"

C:
	setenv("MYVAR", "Some text string 1234", 1);  // 1 = overwrite val, if it exists
	printf("%s\n", getenv("MYVAR"));


Manipulating the env through a C program.. local only to that process

$ cat bashAndCEnvironment.c
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
int main(int argc, char* argv[])
{
	char array[1000];
	printf("Variable %s has value: %s\n", argv[1], getenv(argv[1]));
	printf("Doubling it!\n");
	strcpy(array, getenv(argv[1]));
	strcat(array, getenv(argv[1]));
	printf("New value of %s will be: %s\n", argv[1], array);
	setenv(argv[1], array, 1);
	printf("Variable %s has value: %s\n", argv[1], getenv(argv[1]));
}


$ MYVAR="TEXT."
$ export MYVAR
$ echo $MYVAR
TEXT.

$ gcc -g -o bashAndCEnvironment bashAndCEnvironment.c

$ bashAndCEnvironment MYVAR
Variable MYVAR has value: TEXT.
Doubling it!
New value of MYVAR will be: TEXT.TEXT.
Variable MYVAR has value: TEXT.TEXT.

$ echo MYVAR
TEXT.


Fork bombs
	-> hilarious

	warning signs:
	-> loop calls fork
	-> code in which child proc creates another child proc (a fork w/in a fork)
	-> child proc is starting up a loop

	-> consider a forkNow var in loop
	-> consider wrapping in a loop where if you hit 50 forks, then abort()  (kill everything!)
	


Proces Management and Zombies   video 2
--------------------------------------------------------------------------------------

ps - boring by itself, not that useful

Brewster's ps:

$ alias
…
alias psme='ps -o ppid,pid,euser,stat,%cpu,rss,args | head -n 1; ps -eH -o
ppid,pid,euser,stat,%cpu,rss,args | grep brewsteb'

$ psme
PPID PID 	EUSER 	STAT %CPU RSS COMMAND
4533 18776  root 	Ss 0.2 4284 sshd: brewsteb [priv]
18776 18778 brewsteb S 0.0 2112 	sshd: brewsteb@pts/8
18778 18779 brewsteb Ss 0.0 2044	 -bash
18779 18911 brewsteb R+ 4.0 1840 		ps -eH -o ppid,pid,euser,stat,%cpu,rss,args
18779 18912 brewsteb S+ 0.0 820 		grep brewsteb


PPID = Parent Proc ID
PID = Proc ID
EUSER = Effective User ID
STAT = execution State

%CPU = % of CPU time this proc occupies
RSS = Real Set Size - kbs of RAM in use by the proc
Command = the actual cmd the user entered



First State Character:
• D Uninterruptible sleep (usually IO)
• R Running or runnable (on run queue)
• S Interruptible sleep (waiting for an event to complete)
• T Stopped, either by a job control signal or because it is
being traced
• Z Defunct ("zombie") process, terminated but not
reaped by its parent



Second State Character (Optional):
• < High-priority (not nice to other users)
• N Low-priority (nice to other users)
• L Has pages locked into memory (for real-time and custom IO)
• s Is a session leader (closes all child processes on termination)
• L Is multi-threaded (Uses pthread)
• + Is in the foreground process group



Zombie aka defunct process:
	-> when a child proc terms, but its parent does not wait for it,
		the proc becomes know as a zombie

	-> child proc must report to their parents b4 their resources will be released by the OS

	-> if parents aren't waiting for children, the proc becomes forever consuming

	-> purpose of a zombie proc is to retain the state that wait() can retrieve, they want to be harvested


Making Zombies:

$ cat forkyouzombie.c

#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

void main()
{
	pid_t spawnPid = -5;
	int childExitStatus = -5;

	spawnPid = fork();
	switch (spawnPid)
	{
		case -1:
			perror("Hull Breach!\n");
			exit(1);
			break;
		case 0:		/* child case */
			printf("CHILD: Terminating!\n");
			break;
		default:
			printf("PARENT: making child a zombie for ten seconds;\n");
			printf("PARENT: Type \"ps -elf | grep \'username\'\" to see the defunct child\n");
			printf("PARENT: Sleeping...\n");
			fflush(stdout);  /* ensure all text outputted b4 sleeping */
			sleep(10);
			waitpid(spawnPid, &childExitStatus, 0);
			break;
	}
	printf("This will be executed by both of us!\n");
	exit(0);
}

$ gcc -o forkyouzombie forkyouzombie.c
$ forkyouzombie

PARENT: making child a zombie for ten seconds;
PARENT: Type "ps -elf | grep 'username'" to see the defunct child
PARENT: Sleeping...
CHILD: Terminating!
This will be executed by both of us!  /* dramatic 10 second pause here */
This will be executed by both of us!

// In a second terminal…
$ ps -elf | grep 'brewsteb' /* reasonable way to use ps */
4 S root 15296 4443 0 80 0 - 32719 unix_s 10:55 ? 00:00:00 sshd: brewsteb [priv]
5 S brewsteb 15298 15296 0 80 0 - 32719 poll_s 10:55 ? 00:00:00 sshd: brewsteb@pts/40
0 S brewsteb 15299 15298 0 80 0 - 30233 wait 10:55 pts/40 00:00:00 -bash
0 S brewsteb 17053 27991 0 80 0 - 981 hrtime 11:15 pts/9 00:00:00 forkyouzombie
1 Z brewsteb 17054 17053 0 80 0 - 0 exit 11:15 pts/9 00:00:00 [forkyouzombie] <defunct>
0 R brewsteb 17057 15299 12 80 0 - 30674 - 11:15 pts/40 00:00:00 ps -elf
0 S brewsteb 17058 15299 0 80 0 - 25829 pipe_w 11:15 pts/40 00:00:00 grep brewsteb
4 S root 27987 4443 0 80 0 - 32719 unix_s 08:51 ? 00:00:00 sshd: brewsteb [priv]
5 S brewsteb 27990 27987 0 80 0 - 32719 poll_s 08:51 ? 00:00:00 sshd: brewsteb@pts/9
0 S brewsteb 27991 27990 0 80 0 - 30234 wait 08:51 pts/9 00:00:00 -bash


Orphan Zombies!
	-> parent proc terms w/out cleaning up its zombies
	-> orphans are adpoted by the init proc (usually pid = 1) which periodically
		(in practice, very quickly) waits() for orphans
		-> thus eventually die


kill
	-> unix cmd to kill pgms
		-> older version called kfork

	-> "kill" = misnomer - it really just sends signals

				\/ pid of proc being signaled
	kill -TERM 1234
		  ^signal to send

		  -> pid > 0, sig sent to the given proc PID
		  -> pid == 0, signal sent to ALL procs int he same proc group as the sender (think 					your shell)
		  -> more trickiness for pid < 0


top

• top allows you to view the processes running on the machine in real
time - one of the few animated built-in programs

$ top
top - 14:14:34 up 34 days, 5:15, 9 users, load average: 0.03, 0.18, 0.22
Tasks: 703 total, 1 running, 697 sleeping, 4 stopped, 1 zombie
Cpu(s): 0.1%us, 0.1%sy, 0.0%ni, 99.8%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%st
Mem: 65922540k total, 7876576k used, 58045964k free, 663988k buffers
Swap: 2588668k total, 0k used, 2588668k free, 5258716k cached

PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND
27609 brewsteb 20 0 27884 1796 996 R 3.4 0.0 0:00.10 top
1 root 20 0 33656 1624 1292 S 0.0 0.0 1:41.47 init
2 root 20 0 0 0 0 S 0.0 0.0 0:09.18 kthreadd
3 root RT 0 0 0 0 S 0.0 0.0 0:21.23 migration/0
4 root 20 0 0 0 0 S 0.0 0.0 0:14.47 ksoftirqd/0
5 root RT 0 0 0 0 S 0.0 0.0 0:00.00 stopper/0


Diagnosing a slow CPU

uptime - cmd show s avg # of runnable procs over several diff periods of time

$ uptime
1:23pm up 25 day(s), 5:59, 72 users, load average: 0.18, 0.19, 0.20

	-> if showing that your runnable queue is consistently larger than the # of corse, CPU is causing a bottleneck/slow-down



$ cat /proc/cpuinfo

processor : 0
vendor_id : GenuineIntel
cpu family : 6
model : 45
model name : Intel(R) Xeon(R) CPU E5-2665 0 @ 2.40GHz
stepping : 7
microcode : 1808
cpu MHz : 2399.993
cache size : 20480 KB
physical id : 0
siblings : 16
core id : 0
cpu cores : 8
apicid : 0
initial apicid : 0
fpu : yes
fpu_exception : yes



Job Control
	-> can we run multiple processes at once? (still retain access to the cmd line)

Foreground/background
	-> can only be one shell foreground proc - its the one you are currently interacting w/
		-> if at the cmd prompt, then your FG pgm is the shell itself!

	-> Processes in the BG can still be executing, but can also be in any number of states
		(first state chars)

	-> no real difference b/w them except
		-> when a user enters a cmd that is intended to run in the FG (normal cmd), the proc started runs to completeion b4 the user is prompted again

		-> when same is done for BG, user immediately prompted agian after the proc is executed

	-> i.e. control input to the terminal is not interrupted by a background process

Start BG
	$ ping www.oregonstate.edu &

	... ping readouts

	Sending TSTp signal stops (not terms) a proc and puts it into the BG
		-> ctrl z sends this signal

jobs - cmd to see what you are running
		-> -l (dash el) to see the proc ids

		-> kill -KILL 31327   (kill proc with this id)
		-> kill -KILL %1 		(kill job 1)



fg - use job #s provided by jobs to manip procs

	fg %1 - bring job 1 from BG to FG and start it again

	fg - bring most recent BG'd job to FG and start running again


bg: 

	bg %1 - spec a stopped pgm in BG and keep it running in BG

	bg - most recent

suspend a proc:

$ ping www.oregonstate.edu 2>/dev/null 1>logfile &
[1] 1660

$ jobs
[1]+ Running ping www.oregonstate.edu 2> /dev/null > /dev/null &

$ kill -TSTP %1
[1]+ Stopped ping www.oregonstate.edu 2> /dev/null > /dev/null

$ jobs
[1]+ Stopped ping www.oregonstate.edu 2> /dev/null > /dev/null



$ history 5

1012 jobs
1013 psme
1014 top
1015 jobs
1016 history 5

exe a previous cmd

$ history 3
1030 jobs
1031 psme
1032 history 3

$ !1030
jobs

$ history 3
1032 history 3
1033 jobs
1034 history 3

$ !-2
jobs

$ !!
jobs

$ history 3
1034 history 3
1035 jobs
1036 history 3



Signals   video 3 --------------------------------------------------------------------------------------

Can we connect our procs together? How can they comm? Are there simple ways?
	-> when a user proc wants to contact the kernal, it uses a system call


Signals are the answer: they interrupt the flow of control by stopping execution
	and jumping to an explicitly spec'd or default signal handler fn

Critical point: signal stell a proc to DO something - take an action b/c a user cmd or an event

Fixed set of signals
	-> can't create own signals
		-> though the programmatic response to and meaing of most signals is up to us

	-> 2 signals w/ no inherent meaning at all - you assign meaning to them by catching them and running code

uses for signals: kernal to proc
	-> notifications
		-> proc did something wrong
		-> timer expired
		-> child proc has completed
		etc..

ufs : proc to proc
	-> suspended or resume exec of procs
	-> term
	-> change modes
	-> change comm methods



Signal # Easy Name Catchable Meaning of Signal sent to Process Default ActionIf Not Caught CoreDump
SIGABRT 6 Abort Yes Terminate; sent by process itself during abort() call which performs no cleanup, unlike exit(). Terminate Yes
SIGQUIT 3 Quit Yes Terminate; sent by user. Terminate Yes
SIGINT 2 Interrupt Yes The process is requested to terminate; performs cleanup; CTRL-C sends this to process and all its children. Terminate No
SIGTERM 15 Terminate Yes The process is requested to terminate; performs cleanup. Terminate No
SIGKILL 9 Kill No Terminate instantly, no cleanup; handled entirely by the kernel; nuke from orbit. Terminate, not catchable No


Signaling a script

$ cat sigtermtest

#!/bin/bash
trap "echo 'SIGTERM Received! Exiting with 0!'; exit 0" SIGTERM
while [ 1 -eq 1 ]
do
echo "nothing" > /dev/null
done

$ sigtermtest &
[1] 1708

$ psme
PPID PID EUSER STAT %CPU RSS COMMAND
4533 751 root Ss 0.0 4284 sshd: brewsteb [priv]
751 767 brewsteb S 0.0 2116 sshd: brewsteb@pts/9
767 768 brewsteb Ss+ 0.0 2176 -bash
4533 1508 root Ss 0.0 4284 sshd: brewsteb [priv]
1508 1510 brewsteb S 0.0 2112 sshd: brewsteb@pts/12
1510 1511 brewsteb Ss 0.0 2064 -bash
1511 1708 brewsteb R 97.5 1220 /bin/bash ./sigtermtest
1511 1731 brewsteb R+ 0.0 1716 ps -eH -o ppid,pid,euser,stat,%cpu,rss,args
1511 1732 brewsteb S+ 0.0 816 grep brewsteb
$ kill -SIGTERM 1708
SIGTERM Received! Exiting with 0!
[1]+ Done sigtermtest


$ alias psme
alias psme='ps -o ppid,pid,euser,stat,%cpu,rss,args | head -n 1;
ps -eH -o ppid,pid,euser,stat,%cpu,rss,args | grep brewsteb'


SIGSEGV - Segmentation
Fault
Yes Invalid memory reference; terminate, no cleanup. Terminate Yes

SIGBUS - Bus Error Yes Non-existent physical address. Terminate Yes

SIGFPE - Floating Point
Error
Yes Sent when a process executes an erroneous floating
point or integer operation, such as divide by zero.
Terminate Yes

SIGILL - Illegal
Instruction
Yes Sent when a process attempts a CPU instruction it cannot
issue (malformed, unknown, wrong permissions).
Terminate Yes

SIGSYS - System Call Yes Sent when a process passes an incompatible argument to
a system call (rare, we use libraries to do this right for us).
Terminate Yes

SIGPIPE - Pipe Yes Sent when a process tries to write to a pipe without
another process attached to the other end of the pipe.
Terminate Yes



Why notify on events?  Branching logic!
	-> clean up mem free()
	-> perform final file writes
	-> write to log files
	-> send signals itself


SIGALRM 14 Alarm Yes Sent by alarm() function, normally sent & caught to
execute actions at a specific time; performs cleanup
Terminate No

SIGSTOP - Stop No Stop execution (but stay alive). Stop, not
catchable
-

SIGTSTP - Terminal Stop Yes Stop execution (but stay alive). Stop -

SIGCONT - Continue Yes Continue (resume) execution if stopped. Continue -

SIGHUP 1 Hang Up Yes Sent to a process when its terminal terminates Terminate No

SIGTRAP - Trap Yes Sent when a trap occurs for debugging, i.e. var value
change, function start, etc.; terminate, no cleanup.
Terminate Yes


Timers
	-> wait a spec'd period of time
		-> busy wait which will consume CPU whiel accomplishing nothing
		-> or, tell kernal that you want notified after a certain amt of time passes

		alarm() or ualarm() fns
			-> after the time spec'd has passed, kernal will send your proc a SIGALRM signal

		sleep()
			-> calls alarm
			-> then calls pause, which puts proc into waiting state
			-> when SIGALARM received, sleep() finally returns


Signal # Easy Name Catchable Meaning of Signal sent to Process Default Action If Not Caught Core Dump

SIGCHLD - Child Terminated  Yes  A foreground or background child process of this process
has terminated, stopped, or continued.  None   -

	-> normally wait() and waitpid() will suspend proc until 1 of its child proc has term'd
	-> using this signal allows a parent proc to do other work instead of going to sleep
		-> will be notified via signal when child terms
		-> when received, proc can (immediately or later) call wait() or waitpid() when ready,
			perhaps leaving the child a zombie for just a little while


SIGUSR1 and SIGUSR2 have no special meaning to the kernal


$ cat sigchldtest

#!/bin/bash
set -m  															/* can omit SIG */
trap "echo 'Triggering a child process termination with a silent ls'; ls > /dev/null" USR1
trap "echo 'SIGCHLD Received! Exiting!'; exit 0" CHLD
while [ 1 -eq 1 ]
do
echo "nothing" > /dev/null
done

$ sigchldtest &
[1] 19141

$ psme
PPID PID EUSER STAT %CPU RSS COMMAND
4533 18174 root Ss 0.0 4280 sshd: brewsteb [priv]
18174 18187 brewsteb S 0.0 2108 sshd: brewsteb@pts/9
18187 18188 brewsteb Ss 0.0 2104 -bash
18188 19141 brewsteb R 102 1224 /bin/bash ./sigchldtest
18188 19159 brewsteb R+ 0.0 1844 ps -eH -o ppid,pid,euser,stat,%cpu,rss,args
18188 19160 brewsteb S+ 0.0 816 grep brewsteb

$ kill -SIGUSR1 19141
Triggering a child process termination with a silent ls
SIGCHLD Received! Exiting!
[1]+ Done sigchldtest

$ psme
PPID PID EUSER STAT %CPU RSS COMMAND
4533 18174 root Ss 0.0 4280 sshd: brewsteb [priv]
18174 18187 brewsteb S 0.0 2108 sshd: brewsteb@pts/9
18187 18188 brewsteb Ss 0.0 2104 -bash
18188 19200 brewsteb R+ 1.0 1844 ps -eH -o ppid,pid,euser,stat,%cpu,rss,args
18188 19201 brewsteb S+ 0.0 820 grep brewsteb


Abnormal Termination : Cord Dumps
	-> some signals
	-> during runtime, if proc crashes due to seg fault, bus error, etc..
	-> contains vars, registers, kernal procs info
	=> logged into a file


Signal Handling API
	-> signals that hit your proc will cause the default action to occur

	-> to change this, organize signals into sets, then assign your own custom defined "signal handler" functions to these sets, to override the default actions and do w/e you want

Need a few utlity functions first..
	
	pause()
		-> sometimes  a proc has nothing to do, so you consider calling sleep(), but you want it to be able to respond to signals, which it CAN'T do in sleep()
			-> use pause()

		-> if signal set to be ignored, then pause() continues to be in effect

		-> if signal causes term, pause() does nothing (b/c proc dies)

		-> if sig caught, the approp signal handler fn will be called
			-> after fn done, pause() rtns -1 and sets errno to EINTR, the proc resumes exe

		-> could issue another pause() and continue on


	raise() and alarm()
		-> can send yourself a spec'd signal immediatley with raise()
			int raise(int signal);

		alarm() fn sends proc SIGALRM signal at a later time
			unsigned int alarm(unsigned int seconds);
			-> alarm() will trn immediately, unlike slee()
			-> can only have 1 active at a time

Utlity type: Signal Sets
	-> list of sig types used elsewhere

	dfined using the special type sigset_t in <signal.h>

	fns for managing:
		segemptyset()
		sigfillset()
		sigaddset()
		sigdelset()

	Declare a signal set:
		sigtset_t my_signal_set;

	Init or reset the signal set to have NO signal types:
		sigemptyset(&my_signal_set);

	Init or reset the signal set to have ALL signal types:
		sigfillset(&my_signal_set);

	Add a single signal type to the set:
		sigaddset(&my_signal_set, signal);

	Remove a single signal type from the set:
		sigdelset(&my_signal_set, signal);


sigaction()
	sigaction() registers a signal handling fn that you've created for a spec'd set of signals
		int sigaction(int signo, struct sigaction *newact, struct sigaction *origact);

			1st parm = signal type of interest (SIGINT, SIGHUP, etc..)
			2nd parm = ptr to a data-filled sigaction struct which describes the action to be 				taken upon receipt of the signal given in the 1st parm
			3rd parm = ptr to another sigaction struct, which the sigaction() fn will use to 				to write out what the handling settings for this signal were BEFORE 				this change was requested

sigaction structure:

	struct sigaction  			/* be careful, this struct shares same name as the fn */
	{
		void (*sa_handler) (int);
		sigset_t sa_mask;
		int sa_flags;
		void (*sa_sigaction) (int, siginfo_t*, void*);
	};

1st attribute should be set to one of 3 vals:
	SIG_DFL :: take the default action for the signal
	SIG_IGN :: ignore the signal
	a ptr to a fn that should be called when this signal is received

pts to fn's in C:
	as defined in sigaction struct:
							\/ indic. sa_handler should pt to a fn that has one parm (an int)
							will hold signal # when fn called (impt b/c multiple signals may be registered to with this struct and the int tells us which sig caused the handler to start)
		void (*sa_handler)(int);
				^ indicates a ptr to fn
		^ indicates fn sa_handler pts to does not rtn anything


Example using function pointer:

#include <stdio.h>

int AddOne(int inputArg);

void main()
{				  \/ the arg type
	int (*fpArg)(int) = AddOne; /* delcares fn ptr var named fpArg and sets qual to the same address as where AddOne() is declared */
	printf("10 + 1 = %d\n", fpArg(10));
}

int AddOne (int input)
{
	return input + 1;
}


sigset_t sa_mask
	-> indicates what sigs should be blocked while the signal handler is executing
		-> blocked = arriving during exe of sa_handler, held until done, then delivered to the process

int sa_flags
	additional instruct flags
		-> SA_RESTHAND
			-> resets sig handler to SIG_DFL (default action) after 1st sig rec'd and handled

		-> SA_SIGINFO
			-> tells kernal to call fn spec'd in the fourth attribute (sa_sigaction), instead of 1st attr (sa_hanlder)

		-> 0 if aren't planning to set flags


void (*sa_sigaction) (int, siginfo_t*, void*);
	-> spec alt sig hndlr fn to be called, only used if you use the SA_SIGINFO flag is set in sa_flags

	-> siginfo_t = struct ptr 
	-> void* ptr allows you to pass in a context, an obsolete, non-posix construct that manages user threads
	-> most of the time we will use sa_hanlder, not sa_sigaction


catching and ignoring signals

$ cat catchingSignals.c
#include <signal.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>

void catchSIGINT(int signo)
{
	char* message = "Caught SIGINT, sleeping for 5 seconds\n";
	write(STDOUT_FILENO, message, 38);  // no printf() during signal handler as it's non-reentratn, no strlen(message) in place of 38 (also non-reent)
	raise(SIGUSR2);  send this proc sigusr2, if this sig is blocked, it'll be delivered when the block is removed
	sleep(5);
}

void catchSIGUSR2(int signo)
{
	char* message = "Caught SIGUSR2, exiting!\n";
	write(STDOUT_FILENO, message, 25);
	exit(0);
}


main()
{
	struct sigaction SIGINT_action = {0}, SIGUSR2_action = {0}, ignore_action = {0};
	
	SIGINT_action.sa_handler = catchSIGINT;
	sigfillset(&SIGINT_action.sa_mask);
	SIGINT_action.sa_flags = 0;
	
	SIGUSR2_action.sa_handler = catchSIGUSR2;
	sigfillset(&SIGUSR2_action.sa_mask);
	SIGUSR2_action.sa_flags = 0;
	
	ignore_action.sa_handler = SIG_IGN;
	
	sigaction(SIGINT, &SIGINT_action, NULL);
	sigaction(SIGUSR2, &SIGUSR2_action, NULL);
	sigaction(SIGTERM, &ignore_action, NULL);
	sigaction(SIGHUP, &ignore_action, NULL);
	sigaction(SIGQUIT, &ignore_action, NULL);
	
	printf("SIGTERM, SIGHUP, and SIGQUIT are disabled.\n");
	printf("Send a SIGUSR2 signal to kill this program.\n");
	printf("Send a SIGINT signal to sleep 5 seconds, then kill this program.\n");
	
	while(1)
		pause();
}






Results:

$ catchingSignals
SIGTERM, SIGHUP, and SIGQUIT are disabled.
Send a SIGUSR2 signal to kill this program.
Send a SIGINT signal to sleep 5 seconds, then kill this program.
^CCaught SIGINT, sleeping for 5 seconds  	// sending SIGINT WITH ^C
Caught SIGUSR2, exiting!

$ catchingSignals &
[1] 29443

$ SIGTERM, SIGHUP, and SIGQUIT are disabled.
Send a SIGUSR2 signal to kill this program.
Send a SIGINT signal to sleep 5 seconds, then kill this program.
$
$
$ kill -SIGTERM 29443  // does nothing, it's disabled
$ kill -SIGUSR2 29443
Caught SIGUSR2, exiting!
[1]+ Done catchingSignals


When calling fork(), child processes inherit and get their own instance
of the signal handler functions declared in the parent - these are assigned
to the same signals as the parent automatically



However, calling exec…() in your process will remove any special signal
handler function you wrote and then assigned to sa_handler or
sa_sigaction previously!


Critical note: SIG_DFL and SIG_IGN are preserved through an exec…().
This is the only way to tell processes you exec…(), that you didn’t write
(like ls, other bash commands, etc.), to ignore particular signals. In other
words, there is no way to set up an arbitrary signal handler for programs
you can’t change: you can only set them to ignore specific signals


blocking signals:
	sigprocmask()


• Signals can arrive any time, including in the middle of a system call!

• System calls are savvy about signals and prevent data loss and corruption
from occurring

• They also prevent partial actions from happening

• Normally, system calls will return an error if a signal interrupts them, and
set errno to EINTR

• You can tell system calls to automatically restart by setting SA_RESTART in
the sa_flags variable of the sigaction struct





















































