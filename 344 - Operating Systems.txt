344 - Operating System Notes

Block 1
======================================================================================

Intro to OS1 video 1
--------------------------------------------------------------------------------------


*nix - very stable

Operating System - software program that sits between software apps and the computational hardware


Program: stored algo or plan of execution

Process: program that has been loaded into memory and is executing

Thread: a line of execution in a process


Standard OS Services

1) Process and thread mgmt
	-> strt new pgm
	-> end proc/thread
	-> debug

2) File i/o mgmt
	-> bits into meaningful structures: files
	-> interfaces for r/w to files
	-> comm w/ external devices
	-> organizing files: directories


3) Interprocess Communication (IPC)
	-> signals, pipes, network sockets (TCP/IP)
	-> including between 2 diff comps


4) Process coordination (contention mgmt)
	-> contention mgmt leads to shared access


Interaction with OS:

Users: GUI and CMD line shell

PGMs:
	Functions: sys calls and API - fns

	Network comms:  msg-based and conn-based




Intro to UNIX  video 2
--------------------------------------------------------------------------------------

Jan 1 1970 - "time zero" for UNIX
	-> text processing added so other people/departments could use UNIX

UNIX rewritten in C in 1972
	-> unix couldn't be turned into a product due to regulations

Linux - initially developed by Linus Torvalds
	-> Unix like
	-> all the little kernel like things that tell it how to do everything can't be shared due to license agreements
	-> this is copied (form of it) and called Linux
	-> adopts POSIX UNIX specs
		-> aka code written here shouldn't need many changes to run on Linux
	-> very stable, robust, and free
	-> first version released 1994


Many distros: kernel + tools
	-> Ubunutu, openSUSE, Red Hat, Debian, Arch Liniux, Chrome OS, Mint etc.
	-> all downloadable, some can be purchased


Distros created with different purposes and features in mind
	-> Ubuntu installs evertyhing easily
	-> Arch Linux is opposite, requiring everything to be installed manually
	-> Tails is built to be private from the ground up


What is the shell? (Modern systems have a GUI, but we are going to look at the shell)

	-> this is the user interface to the operating system - a text-based command line interpreter aka prompt

	-> Provides acces to all UNIX user-lvl pgms
		-> start pgms
		-> manage processes (job ctrl)
		-> connect together processes (pipes)
		-> manage i/o to and from processes (redirection)
		-> kill pgms


Shell Prompts:
	-> traditional prompt and cursor - your commands go after the prompt
	-> customizable

	-> $ - typical prompt for BASH



ls -a (-a is the switch to show hidden files)


Most Common UNIX Commands:

directory/file mgmt:
	-> cd, pwd, ls, mkdir, rmdir, mv, cp, rm, ln, chmod

	cd: navigate directories
		~ to home

	pwd: print out current path

	ls: show files/folders in current directory
		-pla
			p: slash
			l: long format
			a: show both visible and hidden folders

		alias: alias l="ls -pla --color=auto"
			-> can type l and this will perform the above command. Kind of like a variable

			*** can be placed into ~/.bashrc so it will be run each time you log into this comp ***

	mkdir: create directory
		-> mkdir tempdir

	rmdir: delete directory
		-> rmdir tempdir  (may not work if not empty)

	rm: delete files (and directories if used recursively)
		NOTE: OSU auto subs rm -i so it has a y/n option to ensure you don't accidentaly delete the file

		-> rm myfile

		-> rm -rf tempdir
			r: delete dir and all files in it
			f: "don't ask me, just do it"

	mv: move or rename files and directories
		-> mv myfile tempdir
			This recognizes if tempdir exists, it will move the file there

		-> my myfile_backup myfile

	cp: copy files and directories
		-> cp myfile myfile_backup

		-> cp myfile ../newfile
			Creates a copy of myfile named newfile 1 folder up

	touch myfile: creates a file if it doesn't exist (0 bytes)
		-> if it does exist, it will update the last used timestamp



file viewing and selecting:
	-> cat, more/less, head, tail, grep, cut

editors:
	-> vi, (x)emacs, pico, textedit

other useful commands:
	-> script, find, telnet, ssh, and many more!


shell auto opens the terminal for reading-from, with one file and for writing-to with 2 files:

when running program ls (or another program):
	
	it comes into existance and has 3 files ready to go

		1) Standard In (file descriptor 0)
			stdin

		2) Standard Out (1)
			stdout

		3) Standard Error (2)
			stderr

			
If you don't specify otherwise, pgm input/output goes to and from the shell prompt by default on every line


Common UNIX Commands - Getting Data from Files:

	echo - sends character data to standard out

		echo test text: outputs test text
			-> sends data to stdout (not screen)
				-> since stdout is to the terminal, it displays to the terminal

		-e - interpret special characters
			echo -e "test text\nnext line"
						test text
						next line

	cat - concatenate character data stored in a file with char data from other files
		-> primarily to dump data to the terminal
		-> sends data to stdout unless explicityly changed from the terminal


	redirecting stdout:  >  operator   (a file is about to be the redirect)

		echo -e "cookie\nbeefcake\napple" > foodlist
		ls  (shows foodlist)
		cat foodlist

			cookie
			beefcake
			apple


	sort - takes data from stdin OR a file and sends the data, alphabetically sorted by line, to stdout

		sort foodlist

			apple
			beefcake
			cookie

	redirecting stdin: <  operator (tells stdin to open from a diff file for reading)

		sort < foodlist
				-> bash opens up the name file, sends the data as input to the pgm on left
				-> sort, meanwhile, has no 1st argument, so it reads data from stdin, and does not know where the data comes from!  It gets sorted and sent to stdout.

			apple
			beefcake
			cookie

	stdin with no redirection: (will be used in program 1)

		cat > list
			-> cat doesn't have an arg and attempts to read from stdin
			-> stdin still has terminal open for input
				-> so, we can get input from the keyboard line by line
					-> hit return after each line
				-> to stop, ^d
			-> bash takes the data from the pgm on left, opens the name file and writes the data into it

		cat list .. will print this data


	sort command can be given input and an output location on same line
		sort < foodlist > sortedList

		or

		sort >sortedList <foodlist
			-> spaces not necessary
			-> not read left to right

		-nr
			n: numeric sort
			r: reverse order

	Shell Filename Expansion
		-> certain metacharacters are expanded and replaced with all files with matching names

		* - matches anything
		? - matches any one characters

		(not regular expression encoding - grep)

	Pipes
		-> provides a way to communicate between commands without using temporary files to hold the data

		echo -e "cookie\nbeefcake\napple" | sort

		echo -e "cookie\nbeefcake\napple" > foodlist
		cat foodlist | sort

		cat foodlist | sort > sortedList
		cat sortedList
				-> cat foodlist piping into sort command then sends it to sortedList

		*a pipe takes the stdout of one command and connects it to the stdin of the next*



	>> operator appends

	more - takes char data and display sonly one screen-full at a time;
		-> nav up, down  and spacebar; quit with q



 

Shell Scripting (bash) video 3
--------------------------------------------------------------------------------------

all commands accessible from shell can be placed into a shell "script"
	-> executed line by line, as if being typed in line by line

shell script
	-> high level
		-> vars, conditionals, loops, etc
	-> interpreted
		-> no compiling, no var dec, no mem mgmt (like js)
	-> powerful/efficient
		-> do a lot with a little code
		-> can interface with any UNIX pgm that uses stdin, stdout, stderr
	-> string and file oriented

	-> used to automate tasks
	-> simplify complex commands, etc
	-> often used to glue pgms together


	Hello World!
	--------------

	#!/bin/bash                        // #! shebag chars (# normally comment) 1st line tells UNIX the path to 											the shell with which to interpret the script
	# Obligatory programming example   // comment
	echo Hello World! 					// line to execute begins here


	Variables:

	assigning (very weakly typed)
		myint=1
		myint=Ben

	to display:
		echo $myint 

	Quotation marks - protecting the text
		-> control expansion of variables within strings of text

		single quotes: no variable expansion

			$  printf 'all your base $abtu\n'
				all your base $abtu
					-> ignored variable


		double quotes: variables are expanded
			$  printf "all your base $abtu\n"
				all your base are belong to us


		\ means to eval literally instead of interpret
		nt="NOTTACHANCE"
		printf "\$nt"; printf "$nt\n"
			result: $ntNOTTACHANCE


Printing example - built from scratch

echo "#!/bin/bash"
	-bash: !/bin/bash": event not found
		-> because the history feature engages when ! is the first character

echo "#\x21/bin/bash"
	-> without -e argument, the hex ASCII code 21 for ! won't be expanded

finally:

echo -e "#\x21/bin/bash" > cAd
echo -e "echo \"cat\"\necho \"doge\"\necho \"kat\"\necho \"doug\"" | sort >> cAd
chmod +x cAd    - make this file be executable, more on chmod later
cAd


We coudl write in emacs, vi, pico, etc...
If ^M (different line endings)
	-> Windows CR and LF
		-> CR returns back to left
		-> LF moves everything up
	-> unix machine = single character

	dox2unix will convert windows line endings to those used by UNIX


Shell keywords:
	-> cmds in bash that are interepred by shell as delimiters, branching constructs, and loops,e tc..

	compgen - generates possible completion matches for various categories of keywords
		-k  all reserved keywords

	AKA, NO KEYWORDS AS VARIABLES

			if
			then
			else
			elif
			fi
			case
			esac
			for
			select
			while
			until
			do
			done
			in
			function
			time
			{
			}
			!
			[[
			]]
			coproc


Environment variables
	-> set of vars that are always available in your shell
	-> ctrl options that change the operation of the shell

	few common ones:
		PATH - set of directories bash will search through to find a command
		HOME - shortcut bak to the home directory (equivalent to ~)
		SHELL - full path ot the default shell
		HOSTNAME - name of the computer you're currently using

		printenv to see all + current contents

		Ex:
		echo $PATH
			-> the directories from left to right (sequentially) will be searched for the command I would have entered


Special Parameters
	-> set of vars always avail in script

	common ones:
		$ - the process ID of the script itself (every running process has a unique PID)
		? - the return value of the previously terminated command or script
		# - the number of args (positional parms) given when a script is executed
		1 - the first arg (pos parms) as of when the script was ran
		2 - the 2nd arg (pos parm) as of when the script was ran
		3, 4, etc.. more on Build-In Shell Variables page

Return Values Examined

exit (bash) and exit() (C) fn rtn results to ? var

cat exittest

		bash if:
		if cmd list
		then
			cmd list
		elif
			cmd list
		then
			cmd list
		else
			cmd list
		fi

Error handling
	-> shell will keep exe'ing even if cmds have the wrong syntax, del files, break things, and general havoc

	-> want shell to exit if any cmds have a prob (rtn non-0 val)
		-> use -e with /bin/bash

		#!/bin/bash -e

	could also do:

	#!/bin/bash
	if cp thesis.docx thesis_current.docx
	then
		rm -f thesis.docx
	else
		echo "copy failed" 1>&2
		exit 1
	fi



	-> most signals will kill script immediately
		-> EG CTRL-C sends SIGINT

For loop:

		$ cat forloop
		#!/bin/bash
		for i in a b c d
		do
		printf "<%s>" $i
		done
		printf "\n"

		$ forloop
		<a><b><c><d>
		$


While loop:

	$ cat whileloop
	#!/bin/bash
	i=0
	while test $i -ne 2
	do
		printf "i = $i, not stopping yet\n"
		i=$(expr $i + 1)
	done
	printf "Stopping, i = $i\n"

	$ whileloop
	i = 0, not stopping yet
	i = 1, not stopping yet
	Stopping, i = 2


Subshells
	-> some operators (like =) and cmds req strings or #s to operate on, not other cmds:

	$ cat sumtest
	#!/bin/bash
	num1=9
	num2=3 + $num1  <- this shit don't work.. need subshells
	echo "num2: $num2"

	$ sumtest
	./sumtest: line 3: +: command not found
	num2:

	-> if we want to increment or set to an arbitrary value, we first have to calc that value and rtn it as TEXT to the script, then the script can continue

	-> these are executed as entirely separate shells (called subshells) in their own processes that run and rtn

	Original method to do this:
		i=`expr $i + 1`    ---- BACKTICKS!

	Preferred method: POSIX compiant, doesn't need escaping when nested
		i=$(expr $i + 1)

	-> both methods eval the exp and grab res's from stdout of the subshell
	-> dbl parens construct does arithmetic expansion and eval directly, no expr cmd needed
			i=$(( 9 + 9 ))
			(( i++ ))


Common UNIX Cmds - Trapping Signals
	-> we are touching really quick here then coming back in block 3

	-> trap - command to catch signals (like SIGINT generated by hitting CTRL + C) and clean up yer mess

	Usage:
		trap <code to execute> list of signals

	Example:

		#!/bin/bash
		TMP="myCoolFilename$$" <- $$ will give process id
		trap "rm -f $TMP; echo 'CTRL+C received, exiting'; exit 1" INT HUP TERM
		echo "lotsa text" > $TMP
		while [ 1 -ne 2 ]
		do
		echo "Never ending loop - hit CTRL+C to exit!"
		done



Bash Script Demos video 4
--------------------------------------------------------------------------------------

readloop

	$ cat readloop
	#!/bin/bash
	while read myLine
	do
		echo "$myLine"
	done < $1  <-------- stuffs contents of file, whos name is the str in the 1st arg, into the 					while loop
	$ readloop test_file
	1 1 1 1 1
	9 3 4 5 5
	6 7 8 9 7
	3 6 8 9 1
	3 4 2 1 4
	6 4 4 7 7
	$


arrayloop  (not recommended for program 1 as it can get complex)

	$ cat arrayloop
	#!/bin/bash
	array=( one two three )
	for i in "${array[@]}"
	do
		echo $i
	done

	$ arrayloop
	one
	two
	three

	$


forloop

	$ cat forloop
	#!/bin/bash
	oneline="1 2 3 4 5"
	for i in $oneline
	do
		echo "i is: $i"
	done

	$ forloop
	i is: 1
	i is: 2
	i is: 3
	i is: 4

sumloop

	$ cat sumloop
	#!/bin/bash
	sum=0
	TMP1=./tempfile
	echo -e "8\n7\n6" > $TMP1

	while read num
	do
		echo "In Loop"
		echo "num: $num"
		sum=`expr $sum + $num`
		echo "sum: $sum"
		echo -e "End of Loop\n"
	done < $TMP1


	$ sumloop
	In Loop
	num: 8
	sum: 8
	End of Loop

	In Loop
	num: 7
	sum: 15
	End of Loop
 
	In Loop
	num: 6
	sum: 21
	End of Loop


stdinread

	$ cat stdinread
	#!/bin/bash
	cat > "tempfile"  -- terminal waits here for input, contd when hit CTRL-D(EOF)
	cat tempfile

	$ stdinread
	I like cheese
	I like cheese


trtest
purpose: convert a row file into a column file and back again

#!/bin/bash
# This script converts a row file ./tempinputfile into a column file ./tempcolfile,
# then back into a row file ./temprowfile<PID>

inputFile="tempinputfile"
tempCol="tempcolfile"
tempRow="temprowfile"

# Make the input row file
echo -e "1\t2\t3\t4\t5" > $inputFile

# Append each number onto the end of a temporary column file by cutting specific columns
cut -c 1 $inputFile > $tempCol
cut -c 3 $inputFile >> $tempCol
cut -c 5 $inputFile >> $tempCol
cut -c 7 $inputFile >> $tempCol
cut -c 9 $inputFile >> $tempCol

# Convert the column file back into a row file
cat $tempCol | tr '\n' '\t' > "$tempRow$$"

# Add a newline char to the end of the row file, for easier printing
echo >> "$tempRow$$"



tr = tranformation of something to something
	ex:
		$tempCol | tr '\n' '\t'   pipes stuff in the file to tr and makes all \n into \t


Wolf Fence Algo
	-> fancy way of saying comment out parts of the code when you can't find the source of the problem (divide and conquer)
		-> bifurcate the code by commenting out half of it and running
		-> change the code to ignore all of the input but one piece and run

when program crashes
	-> creates a core dump file (except with shell scripts)
	to view: gdb myprogram -c coredumpfile


Trace statements!!! - what and where
	-> print out the val of vars as you go (what)
	-> print out where you currently are (where)


		What and where:
		About to Begin Loop: j = 0
		Now At Start of Loop: i = 0, j = 0
		Sum() function ran: i = 1, j = 1844835813859
		Executed file read: i = 1, j = ^^^^^^^ºØĆ@«
		Contents of file read: fj8283jJ*#Jf8j32@fj
		Now at End of Loop: i = MDKMDKMDK, j = 42941492
		Start missile laun^C ^C ^C ^C


Debugging Bash Shell scripts

	Enable print of cmd traces before executing each command:
		-> add -x to the end of the first line of the script
			#!/bin/bash -x

	OR

	Launch the script w/ a shell that has cmd traces enabled:
		bash -x sumloop











Ways to run script:
chmod 755 scriptname   (gives permission to run the script)
	-> tool to set defaults is unmask, but we really don't want to set all files you create as executables
bash scriptname
chmod +x scriptname    <- should use this one to create the executable, then type scriptname





